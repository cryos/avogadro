diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 0000000..1ff0c42
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1,63 @@
+###############################################################################
+# Set default behavior to automatically normalize line endings.
+###############################################################################
+* text=auto
+
+###############################################################################
+# Set default behavior for command prompt diff.
+#
+# This is need for earlier builds of msysgit that does not have it on by
+# default for csharp files.
+# Note: This is only used by command line
+###############################################################################
+#*.cs     diff=csharp
+
+###############################################################################
+# Set the merge driver for project and solution files
+#
+# Merging from the command prompt will add diff markers to the files if there
+# are conflicts (Merging from VS is not affected by the settings below, in VS
+# the diff markers are never inserted). Diff markers may cause the following 
+# file extensions to fail to load in VS. An alternative would be to treat
+# these files as binary and thus will always conflict and require user
+# intervention with every merge. To do so, just uncomment the entries below
+###############################################################################
+#*.sln       merge=binary
+#*.csproj    merge=binary
+#*.vbproj    merge=binary
+#*.vcxproj   merge=binary
+#*.vcproj    merge=binary
+#*.dbproj    merge=binary
+#*.fsproj    merge=binary
+#*.lsproj    merge=binary
+#*.wixproj   merge=binary
+#*.modelproj merge=binary
+#*.sqlproj   merge=binary
+#*.wwaproj   merge=binary
+
+###############################################################################
+# behavior for image files
+#
+# image files are treated as binary by default.
+###############################################################################
+#*.jpg   binary
+#*.png   binary
+#*.gif   binary
+
+###############################################################################
+# diff behavior for common document formats
+# 
+# Convert binary document formats to text before diffing them. This feature
+# is only available from the command line. Turn it on by uncommenting the 
+# entries below.
+###############################################################################
+#*.doc   diff=astextplain
+#*.DOC   diff=astextplain
+#*.docx  diff=astextplain
+#*.DOCX  diff=astextplain
+#*.dot   diff=astextplain
+#*.DOT   diff=astextplain
+#*.pdf   diff=astextplain
+#*.PDF   diff=astextplain
+#*.rtf   diff=astextplain
+#*.RTF   diff=astextplain
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1cbeb8f..4467acc 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -7,7 +7,6 @@ set(Avogadro_VERSION_MINOR 2)
 set(Avogadro_VERSION_PATCH 0)
 set(Avogadro_VERSION "${Avogadro_VERSION_MAJOR}.${Avogadro_VERSION_MINOR}")
 set(Avogadro_VERSION_FULL "${Avogadro_VERSION}.${Avogadro_VERSION_PATCH}")
-
 set(CMAKE_MODULE_PATH ${Avogadro_SOURCE_DIR}/cmake/modules)
 
 cmake_policy(SET CMP0003 NEW)
@@ -51,6 +50,7 @@ if (CMAKE_COMPILER_IS_GNUCXX)
 #  set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wshadow -Wold-style-cast")
   endif()
   add_definitions (-D_BSD_SOURCE)
+ 
   # Set some linker flags
   if(CMAKE_SYSTEM_NAME MATCHES Linux)
     set(CMAKE_SHARED_LINKER_FLAGS
diff --git a/CMakeLists.txt~ b/CMakeLists.txt~
new file mode 100644
index 0000000..70319f1
--- /dev/null
+++ b/CMakeLists.txt~
@@ -0,0 +1,567 @@
+cmake_minimum_required(VERSION 2.8.9)
+project(Avogadro) # the name of your project
+
+# The Avogadro version number, currently used by the Avogadro library too
+set(Avogadro_VERSION_MAJOR 1)
+set(Avogadro_VERSION_MINOR 2)
+set(Avogadro_VERSION_PATCH 0)
+set(Avogadro_VERSION "${Avogadro_VERSION_MAJOR}.${Avogadro_VERSION_MINOR}")
+set(Avogadro_VERSION_FULL "${Avogadro_VERSION}.${Avogadro_VERSION_PATCH}")
+set (CMAKE_CXX_COMPILER C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\cl.exe)
+set(CMAKE_MODULE_PATH ${Avogadro_SOURCE_DIR}/cmake/modules)
+
+cmake_policy(SET CMP0003 NEW)
+
+# this is adapted from KDE's FindKDE4Internal.cmake : default the build type to
+# "release with debug info".
+#
+# We will define two other build types: Debug and Release.
+# These names are case-insensitive i.e. you can do -DCMAKE_BUILD_TYPE=debug
+if(NOT CMAKE_BUILD_TYPE)
+  set(CMAKE_BUILD_TYPE RelWithDebInfo)
+endif()
+message(STATUS "The build type is ${CMAKE_BUILD_TYPE}")
+
+include(CheckCXXCompilerFlag)
+include(MacroEnsureVersion)
+include(TestIfWeNeedFPermissive)
+
+# use mulithreaded dll runtime on windows when using MSVC
+if (MSVC)
+  # Make sure the build is parallelised for faster builds
+  set(CMAKE_CXX_FLAGS"${CMAKE_CXX_FLAGS} /MP")
+  # Do not generate manifests for the plugins - caused issues loading plugins
+  set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /MANIFEST:NO")
+endif()
+
+###########################################################
+# Here I am adding GCC magic from KDE. With these settings#
+# compiler issues are fixed and more warnings are issued. #
+###########################################################
+# We should always respect the users CXXFLAGS if they have set them
+if (CMAKE_COMPILER_IS_GNUCXX)
+  set (CMAKE_CXX_FLAGS_WARN "-Wnon-virtual-dtor -Wno-long-long -ansi -Wcast-align -Wchar-subscripts -Wall -Wextra -Wpointer-arith -Wformat-security -fno-check-new -fno-common -pedantic")
+  # On Linux with GCC 4.3+ these flags generate thousands of warnings, so they
+  # are now optional. Most of the warnings are in included headers.
+  option(EXTRA_WARNINGS
+    "Enable extra GCC warnings - can generate thousands" OFF)
+  if(EXTRA_WARNINGS)
+    # Enable extra compiler warnings for extra checking
+    set (CMAKE_CXX_FLAGS_WARN "${CMAKE_CXX_FLAGS_WARN} -Wconversion -Woverloaded-virtual -Wfloat-equal")
+#  set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wshadow -Wold-style-cast")
+  endif()
+  add_definitions (-D_BSD_SOURCE)
+  # Set some linker flags
+  if(CMAKE_SYSTEM_NAME MATCHES Linux)
+    set(CMAKE_SHARED_LINKER_FLAGS
+      "-Wl,--fatal-warnings -Wl,--no-undefined -lc ${CMAKE_SHARED_LINKER_FLAGS}")
+    set(CMAKE_SHARED_LINKER_FLAGS
+      "-Wl,--enable-new-dtags ${CMAKE_SHARED_LINKER_FLAGS}")
+    set(CMAKE_MODULE_LINKER_FLAGS
+      "-Wl,--fatal-warnings -Wl,--no-undefined -lc ${CMAKE_SHARED_LINKER_FLAGS}")
+    set(CMAKE_MODULE_LINKER_FLAGS
+      "-Wl,--enable-new-dtags ${CMAKE_SHARED_LINKER_FLAGS}")
+    set (CMAKE_EXE_LINKER_FLAGS
+      "-Wl,--fatal-warnings -Wl,--no-undefined -lc ${CMAKE_SHARED_LINKER_FLAGS}")
+    set(CMAKE_EXE_LINKER_FLAGS
+      "-Wl,--enable-new-dtags ${CMAKE_EXE_LINKER_FLAGS}")
+  endif()
+  # Now check if we can use visibility to selectively export symbols
+  # Get the GCC version - from KDE4 cmake files
+  exec_program(${CMAKE_C_COMPILER} ARGS --version OUTPUT_VARIABLE	_gcc_version_info)
+  string (REGEX MATCH "[345]\\.[0-9]\\.[0-9]" _gcc_version "${_gcc_version_info}")
+  # gcc on mac just reports: "gcc (GCC) 3.3 20030304 ..." without the
+  # patch level, handle this here:
+  if (NOT _gcc_version)
+    string (REGEX REPLACE ".*\\(GCC\\).* ([34]\\.[0-9]) .*" "\\1.0" _gcc_version "${_gcc_version_info}")
+  endif ()
+
+  # No RTTI flag
+  check_cxx_compiler_flag(-fno-rtti HAVE_NO_RTTI)
+  if(HAVE_NO_RTTI)
+    set(NO_RTTI_FLAG "-fno-rtti")
+    # RTTI flag
+    check_cxx_compiler_flag(-frtti HAVE_RTTI)
+    if(HAVE_RTTI)
+      set(RTTI_FLAG "-frtti")
+    else()
+      set(RTTI_FLAG "")
+    endif()
+  else()
+    set(NO_RTTI_FLAG "")
+    set(RTTI_FLAG "")
+  endif()
+
+  if(NOT APPLE) # Mac GCC42 compiler has bug
+    check_cxx_compiler_flag(-fvisibility=hidden HAVE_GCC_VISIBILITY)
+    set(HAVE_GCC_VISIBILITY ${HAVE_GCC_VISIBILITY} CACHE BOOL "GCC support for hidden visibility")
+    macro_ensure_version("4.1.0" "${_gcc_version}" GCC_IS_NEWER_THAN_4_1)
+    macro_ensure_version("4.2.0" "${_gcc_version}" GCC_IS_NEWER_THAN_4_2)
+    set(_GCC_COMPILED_WITH_BAD_ALLOCATOR FALSE)
+    if (GCC_IS_NEWER_THAN_4_1)
+      exec_program(${CMAKE_C_COMPILER} ARGS -v OUTPUT_VARIABLE _gcc_alloc_info)
+      string(REGEX MATCH "(--enable-libstdcxx-allocator=mt)" _GCC_COMPILED_WITH_BAD_ALLOCATOR "${_gcc_alloc_info}")
+    endif ()
+
+    if (HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR)
+      # We have all the parts necessary - use visibility support
+      add_definitions(-DHAVE_GCC_VISIBILITY)
+      set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility=hidden")
+      if (GCC_IS_NEWER_THAN_4_2)
+        set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility-inlines-hidden")
+      endif()
+    endif()
+  endif()
+  # Set up additional build flags for particular build types. These will be added to CMAKE_CXX_FLAGS,
+  # they will not replace them.
+  set(CMAKE_CXX_FLAGS_RELEASE "-O2 -DNDEBUG -DQT_NO_DEBUG_OUTPUT -Wl,-s")
+  set(CMAKE_CXX_FLAGS_RELWITHDEBINFO
+    "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} ${CMAKE_CXX_FLAGS_WARN}")
+  set(CMAKE_CXX_FLAGS_DEBUG   "-g3 -fno-inline ${CMAKE_CXX_FLAGS_WARN}")
+
+  TEST_IF_WE_NEED_FPERMISSIVE(NEED_FPERMISSIVE)
+  if(NEED_FPERMISSIVE)
+    #OK, adding -fpermissive to the C++ compiler flags
+    #Workaround for a problem with Boost.Python and GCC >= 4.3.1
+    #Further information: cmake/modules/TestIfWeNeedFPermissive.cmake
+    set (CMAKE_CXX_FLAGS   "${CMAKE_CXX_FLAGS} -fpermissive")
+  endif()
+
+  # define WITH_SSE2 to enable the SSE2 instruction set.
+  # Available on Pentium 4, Athlon 64, and newer CPUs.
+  # Enabled by default on the x86_64 architecture, but not on the x86 architecture.
+  # If SSE2 is enabled, Eigen uses it by default; this can be disabled by
+  # definining EIGEN_DONT_VECTORIZE.
+  if(WITH_SSE2)
+    message(STATUS "Enabling the SSE2 instruction set")
+    set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -msse2")
+  endif()
+endif()
+
+
+# Intel C++ Compiler
+# Note: Windows version uses different options!
+if(${CMAKE_CXX_COMPILER_ID} MATCHES Intel AND UNIX)
+  # Disable warnings:
+  # 981 - operands are evaluated in unspecified order
+  # 1599 - foreach
+  set (CMAKE_CXX_FLAGS_WARN "-Wnon-virtual-dtor -ansi -Wcheck -Wall -Wpointer-arith -wd981,1599")
+  option(EXTRA_WARNINGS
+    "Enable extra Intel Compiler warnings and remarks" OFF)
+  if(EXTRA_WARNINGS)
+    # Enable extra compiler warnings for extra checking
+    set (CMAKE_CXX_FLAGS_WARN "${CMAKE_CXX_FLAGS_WARN} -w2 -Weffc++ -wd2012,2015")
+  else()
+    # 810 - conversion to float
+    # 383 - value copied to temporary, reference to temporary used
+    # 1418 - external function definition with no prior declaration
+    set (CMAKE_CXX_FLAGS_WARN "${CMAKE_CXX_FLAGS_WARN} -wd383,810,1418")
+  endif()
+  add_definitions (-D_BSD_SOURCE)
+  # Set some linker flags
+  if(CMAKE_SYSTEM_NAME MATCHES Linux)
+    set(CMAKE_SHARED_LINKER_FLAGS
+      "-lc ${CMAKE_SHARED_LINKER_FLAGS}")
+    set(CMAKE_MODULE_LINKER_FLAGS
+      "-lc ${CMAKE_MODULE_LINKER_FLAGS}")
+    set (CMAKE_EXE_LINKER_FLAGS
+      "-lc ${CMAKE_EXE_LINKER_FLAGS}")
+  endif()
+
+  # No RTTI flag
+  check_cxx_compiler_flag(-fno-rtti HAVE_NO_RTTI)
+  if(HAVE_NO_RTTI)
+    set(NO_RTTI_FLAG "-fno-rtti")
+    # RTTI flag
+    check_cxx_compiler_flag(-frtti HAVE_RTTI)
+    if(HAVE_RTTI)
+      set(RTTI_FLAG "-frtti")
+    else()
+      set(RTTI_FLAG "")
+    endif()
+  else()
+    set(NO_RTTI_FLAG "")
+    set(RTTI_FLAG "")
+  endif()
+
+  check_cxx_compiler_flag(-fvisibility=hidden HAVE_INTEL_VISIBILITY)
+  set(HAVE_INTEL_VISIBILITY ${HAVE_INTEL_VISIBILITY} CACHE BOOL "Intel Compiler support for hidden visibility")
+  if(HAVE_INTEL_VISIBILITY)
+    add_definitions(-DHAVE_GCC_VISIBILITY)
+    set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility=hidden")
+    check_cxx_compiler_flag(-fvisibility-inlines-hidden HAVE_INTEL_VISIBILITY_INLINES)
+    set(HAVE_INTEL_VISIBILITY_INLINES ${HAVE_INTEL_VISIBILITY_INLINES} CACHE BOOL "Intel Compiler support for -fvisibility-inlines-hidden")
+    if(HAVE_INTEL_VISIBILITY_INLINES)
+      set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility-inlines-hidden")
+    endif()
+  endif()
+
+  set(CMAKE_C_FLAGS_RELEASE "-O3 -ipo1 -DNDEBUG -DQT_NO_DEBUG_OUTPUT -Wl,-s")
+  set(CMAKE_CXX_FLAGS_RELEASE "-O3 -ipo1 -DNDEBUG -DQT_NO_DEBUG_OUTPUT -Wl,-s")
+
+  set(CMAKE_CXX_FLAGS_RELWITHDEBINFO
+    "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} ${CMAKE_CXX_FLAGS_WARN}")
+  set(CMAKE_CXX_FLAGS_DEBUG   "-g3 -fno-inline ${CMAKE_CXX_FLAGS_WARN}")
+
+  TEST_IF_WE_NEED_FPERMISSIVE(NEED_FPERMISSIVE)
+  if(NEED_FPERMISSIVE)
+    #OK, adding -fpermissive to the C++ compiler flags
+    #Workaround for a problem with Boost.Python and GCC >= 4.3.1
+    #Further information: cmake/modules/TestIfWeNeedFPermissive.cmake
+    set (CMAKE_CXX_FLAGS   "${CMAKE_CXX_FLAGS} -fpermissive")
+  endif()
+
+  # define WITH_SSE2 to enable the SSE2 instruction set.
+  # Available on Pentium 4, Athlon 64, and newer CPUs.
+  # If SSE2 is enabled, Eigen uses it by default; this can be disabled by
+  # definining EIGEN_DONT_VECTORIZE.
+  if(CMAKE_SIZEOF_VOID_P EQUAL 8 OR WITH_SSE2)
+    message(STATUS "Enabling the SSE2 instruction set")
+    set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -msse2")
+  endif()
+endif()
+
+set(I18N_LANGUAGE "" CACHE STRING "Build i18n only for selected language")
+
+find_package(Qt4 4.6.0 REQUIRED) # find and setup Qt4 for this project
+find_package(OpenGL REQUIRED) # find and setup OpenGL
+find_package(X11) # find and setup X11 (not required for Mac and Windows)
+find_package(Linguist) # find and setup Linguist
+if(NOT Linguist_FOUND)
+  message(WARNING " Qt4 Linguist not found, please install it if you want Avogadro translations")
+endif()
+
+find_package(Eigen3) # find and setup Eigen3 if available
+if(NOT EIGEN3_FOUND)
+   message(STATUS "Cannot find Eigen3, trying Eigen2")
+   find_package(Eigen2 REQUIRED) # Some version is required
+else()
+# Use Stage10 Eigen3 support
+   set (EIGEN2_SUPPORT_STAGE10_FULL_EIGEN2_API TRUE)
+endif()
+
+find_package(ZLIB REQUIRED)
+find_package(OpenBabel2 REQUIRED) # find and setup OpenBabel
+
+if (Q_WS_X11)
+  find_package(X11 REQUIRED) # avogadro/src/main.cpp calls XInitThread().
+endif()
+
+# Check if we are building from a Git clone or a released version
+function(git_version dir version_var)
+  # Function to figure out the Git short version hash
+  if(EXISTS ${dir}/.git)
+    execute_process(COMMAND git rev-parse --short HEAD
+            WORKING_DIRECTORY ${dir}
+            OUTPUT_VARIABLE var)
+    string(REGEX REPLACE "\n" "" var "${var}")
+    message(STATUS "Git revision found to be ${var}")
+    set(${version_var} "${var}" PARENT_SCOPE)
+  endif(EXISTS ${dir}/.git)
+endfunction()
+
+git_version(${CMAKE_SOURCE_DIR} SCM_REVISION)
+message(STATUS "Found Git revision is: ${SCM_REVISION}")
+if(SCM_REVISION)
+  message(STATUS "Building development version from Git clone.")
+else()
+  message(STATUS "Building released version.")
+endif()
+
+###########################################################
+# Python Support: Detect and report all stuff here.       #
+# Subdirectories can use: ALL_PYTHON_FOUND                #
+###########################################################
+option(ENABLE_PYTHON "Enable python support" ON)
+if(ENABLE_PYTHON)
+  include(PythonDeps)
+  if(ALL_PYTHON_FOUND)
+    message(STATUS "All python dependencies found - Python support enabled")
+  else()
+    set(ENABLE_PYTHON FALSE)
+    message(WARNING "Not all python dependencies are found - Python support disabled")
+  endif()
+else()
+  message(STATUS "Python support disabled.")
+endif()
+
+# Unit testing, mainly useful for developers and so defaults to off
+option(ENABLE_TESTS "Enable unit testing" OFF)
+if(ENABLE_TESTS)
+  set(QT_USE_QTTEST TRUE)
+  enable_testing()
+  include (CTest)
+  message(STATUS "Unit testing enabled, run make test to run them")
+endif()
+
+# GLSL support is needed for OpenGL shaders
+option(ENABLE_GLSL "Enable GLSL support" OFF)
+if(ENABLE_GLSL)
+  find_package(GLEW)
+  if(GLEW_FOUND)
+    message(STATUS "GLEW found and GLSL support enabled")
+    add_definitions( -DENABLE_GLSL )
+  else()
+    message(WARNING "GLEW not found, please install it if you require GLSL")
+  endif()
+endif()
+
+# Multithreaded OpenGL. Seems mostly broken on Linux right now.
+option(ENABLE_THREADEDGL "Enable threaded OpenGL rendering" OFF)
+if(ENABLE_THREADEDGL)
+  add_definitions( -DENABLE_THREADED_GL )
+  set(THREADED_GL true)
+  message(STATUS "Threaded OpenGL rendering enabled - needs more testing")
+else()
+  set(THREADED_GL false)
+  message(STATUS "Threaded OpenGL rendering not enabled")
+endif()
+
+# Should a self-contained package be created?
+option(ENABLE_AVO_PACKAGE "Enable creation of a self-contained package" OFF)
+if(ENABLE_AVO_PACKAGE)
+  add_definitions(-DAVO_APP_BUNDLE)
+endif()
+
+# Should a versioned plugin directory be used, i.e. avogadro/1.0.
+option(ENABLE_VERSIONED_PLUGIN_DIR "Enable versioned plugin directory" ON)
+mark_as_advanced(ENABLE_VERSIONED_PLUGIN_DIR)
+
+# Set up our path handling, inspired by the path handling used in KDE
+set(LIB_SUFFIX "" CACHE STRING "Suffix of the directory name, e.g. 64 for lib64")
+set(SHARE_INSTALL_PREFIX "share"
+    CACHE STRING "Base directory for shared data")
+set(BIN_INSTALL_DIR      "bin"
+    CACHE STRING "Install dir for binaries")
+
+# Set up the plugin directory
+if(ENABLE_VERSIONED_PLUGIN_DIR)
+  set(Plugin_Version "/${Avogadro_VERSION_MAJOR}_${Avogadro_VERSION_MINOR}")
+else()
+  set(Plugin_Version "")
+endif()
+
+if(UNIX)
+  set(LIB_INSTALL_DIR      "lib${LIB_SUFFIX}"
+      CACHE STRING "Install dir for libraries" FORCE)
+  set(Avogadro_PLUGIN_INSTALL_DIR
+      "${LIB_INSTALL_DIR}/avogadro${Plugin_Version}"
+      CACHE STRING "Install dir for plugins" FORCE)
+else()
+  set(LIB_INSTALL_DIR      "${BIN_INSTALL_DIR}"
+      CACHE STRING "Install dir for libraries" FORCE)
+  set(Avogadro_PLUGIN_INSTALL_DIR
+      "lib${LIB_SUFFIX}/avogadro${Plugin_Version}"
+      CACHE STRING "Install dir for plugins" FORCE)
+endif()
+set(INCLUDE_INSTALL_DIR  "include"
+    CACHE STRING "Install dir for include files")
+set(I18N_INSTALL_DIR     "${SHARE_INSTALL_PREFIX}/avogadro/i18n"
+    CACHE STRING "Install dir for i18n files")
+set(XDG_APPS_INSTALL_DIR "${SHARE_INSTALL_PREFIX}/applications"
+    CACHE STRING "Install dir for application files")
+set(XDG_ICON_INSTALL_DIR "${SHARE_INSTALL_PREFIX}/pixmaps"
+    CACHE STRING "Install dir for application icons")
+
+# Some rpath handling for Linux and Mac
+option(ENABLE_RPATH "Enable rpath support on Linux and Mac" ON)
+if(UNIX AND ENABLE_RPATH)
+  message(STATUS "RPath support enabled for installed binaries and libraries")
+  if(APPLE)
+    # Funky path logic in order to get the Avogadro application bundle working
+    set(CMAKE_BUNDLE_LOCATION "/Applications")
+    if(USE_VERSIONED_BUNDLE_LOCATION)
+      set(CMAKE_BUNDLE_NAME "Avogadro${Avogadro_VERSION}")
+    else(USE_VERSIONED_BUNDLE_LOCATION)
+      set(CMAKE_BUNDLE_NAME "Avogadro")
+    endif(USE_VERSIONED_BUNDLE_LOCATION)
+    set(CMAKE_INSTALL_PREFIX "/Applications/${CMAKE_BUNDLE_NAME}.app/Contents")
+    set(CMAKE_INSTALL_NAME_DIR "@executable_path/../${LIB_INSTALL_DIR}")
+  else()
+    set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/${LIB_INSTALL_DIR}")
+    set(CMAKE_SKIP_BUILD_RPATH FALSE)
+    set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
+    set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
+  endif()
+endif()
+
+# Add support for an uninstall target
+configure_file(
+  "${CMAKE_MODULE_PATH}/cmake_uninstall.cmake.in"
+  "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
+  IMMEDIATE @ONLY)
+
+add_custom_target(uninstall
+  "${CMAKE_COMMAND}" -P
+  "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake")
+
+# Configure and install an Avogadro CMake style configuration file
+configure_file(
+  "${CMAKE_MODULE_PATH}/AvogadroConfig.cmake.in"
+  "${Avogadro_BINARY_DIR}/AvogadroConfig.cmake"
+  IMMEDIATE @ONLY)
+
+configure_file(
+  "${CMAKE_MODULE_PATH}/AvogadroConfigVersion.cmake.in"
+  "${Avogadro_BINARY_DIR}/AvogadroConfigVersion.cmake"
+  IMMEDIATE @ONLY)
+
+if(APPLE)
+  install(FILES
+    "${Avogadro_BINARY_DIR}/AvogadroConfig.cmake"
+    "${Avogadro_BINARY_DIR}/AvogadroConfigVersion.cmake"
+    DESTINATION Resources)
+else()
+  install(FILES
+    "${Avogadro_BINARY_DIR}/AvogadroConfig.cmake"
+    "${Avogadro_BINARY_DIR}/AvogadroConfigVersion.cmake"
+    DESTINATION "${LIB_INSTALL_DIR}/avogadro")
+endif()
+
+if (UNIX)
+  if(ENABLE_AVO_PACKAGE)
+    if(APPLE)
+      # Make sure to copy Qt plugins and translations
+      file(GLOB qt_TRANSLATIONS "${QT_TRANSLATIONS_DIR}/qt*.qm")
+      install(FILES ${qt_TRANSLATIONS}
+        DESTINATION "${I18N_INSTALL_DIR}"
+        )
+      # FIXME: These need to have the install-name tool run on them
+      install(DIRECTORY "${QT_PLUGINS_DIR}"
+        DESTINATION "${CMAKE_INSTALL_PREFIX}"
+        )
+    else()
+#      # Make sure to copy Qt plugins and translations
+#      file(GLOB qt_TRANSLATIONS "${QT_TRANSLATIONS_DIR}/qt*.qm")
+#      install(FILES ${qt_TRANSLATIONS}
+#    	DESTINATION "${CMAKE_INSTALL_PREFIX}/lib/qt/translations"
+#    	)
+#      # FIXME: These need to have the install-name tool run on them
+#      install(DIRECTORY "${QT_PLUGINS_DIR}"
+#    	DESTINATION "${CMAKE_INSTALL_PREFIX}/lib/qt"
+#    	)
+#      file(GLOB qt_libs "${QT_LIBRARY_DIR}/libQtCore.so* ${QT_LIBRARY_DIR}/libQtGui.so* ${QT_LIBRARY_DIR}/libQtOpenGL.so* ${QT_LIBRARY_DIR}/libQtNetwork.so*")
+#      install(FILES ${qt_libs}
+#        DESTINATION "${CMAKE_INSTALL_PREFIX}/lib/qt"
+#        )
+#      # FIXME: Add others
+#      set(X11_LIBRARIES ${X11_ICE_LIB} ${X11_SM_LIB} ${X11_X11_LIB})
+#      install(LIBRARY ${X11_LIBRARIES}
+#        DESTINATION "${CMAKE_INSTALL_PREFIX}/lib/X11"
+#        )
+#      install(LIBRARY ${OPENGL_LIBRARIES}
+#        DESTINATION "${CMAKE_INSTALL_PREFIX}/lib/gl"
+#        )
+#      install (LIBRARY ${ZLIB_LIBRARY}
+#        DESTINATION "${CMAKE_INSTALL_PREFIX}/lib"
+#        )
+       set(about_files ${CMAKE_CURRENT_SOURCE_DIR}/README
+                       ${CMAKE_CURRENT_SOURCE_DIR}/COPYING
+                       ${CMAKE_CURRENT_SOURCE_DIR}/AUTHORS
+         )
+       install(FILES ${about_files}
+         DESTINATION "${CMAKE_INSTALL_PREFIX}"
+         )
+    endif()
+  endif()
+endif()
+
+# Install the configuration files to help find Avogadro
+install(FILES
+  "${CMAKE_MODULE_PATH}/AvogadroUse.cmake"
+  DESTINATION "${Avogadro_PLUGIN_INSTALL_DIR}")
+
+# Install the find modules we require to be present
+install(FILES
+  "${CMAKE_MODULE_PATH}/FindEigen2.cmake"
+  "${CMAKE_MODULE_PATH}/FindEigen3.cmake"
+  "${CMAKE_MODULE_PATH}/FindGLEW.cmake"
+  DESTINATION "${Avogadro_PLUGIN_INSTALL_DIR}/cmake")
+
+configure_file(
+  "${CMAKE_MODULE_PATH}/CTestCustom.cmake.in"
+  "${Avogadro_BINARY_DIR}/CTestCustom.cmake"
+  IMMEDIATE @ONLY
+)
+
+# Place binaries and libraries in the root of the build directory
+set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin"
+    CACHE STRING "Binary build output directory")
+set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib${LIB_SUFFIX}"
+    CACHE STRING "Library build output directory")
+mark_as_advanced(CMAKE_LIBRARY_OUTPUT_DIRECTORY
+  CMAKE_RUNTIME_OUTPUT_DIRECTORY)
+
+# tell cmake to process CMakeLists.txt in that subdirectory
+add_subdirectory(libavogadro)
+add_subdirectory(avogadro)
+add_subdirectory(doc)
+
+# Linux/Windows default: ${PREFIX}/share/avogadro/fragments
+set(avogadro_FRAGMENTS ${SHARE_INSTALL_PREFIX}/avogadro)
+
+# When installing, make sure to install some fragments
+install(DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/fragments"
+        DESTINATION ${avogadro_FRAGMENTS})
+install(DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/builder"
+        DESTINATION ${avogadro_FRAGMENTS})
+install(DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/crystals"
+        DESTINATION ${avogadro_FRAGMENTS})
+
+# Prefix to use in avopkg, pkg-config and QMake integration
+if(ENABLE_AVO_PACKAGE)
+  set(USER_PREFIX "@prefix@")
+else()
+  set(USER_PREFIX ${CMAKE_INSTALL_PREFIX})
+endif()
+
+# pkg-config
+if(UNIX)
+  configure_file(
+    "${CMAKE_CURRENT_SOURCE_DIR}/avogadro.pc.in"
+    "${CMAKE_CURRENT_BINARY_DIR}/avogadro.pc" @ONLY)
+  set(PC_FILES "${CMAKE_CURRENT_BINARY_DIR}/avogadro.pc")
+  install(FILES ${PC_FILES} DESTINATION ${LIB_INSTALL_DIR}/pkgconfig)
+endif()
+
+# avopkg
+if(UNIX)
+  configure_file(
+    "${CMAKE_CURRENT_SOURCE_DIR}/avopkg.in"
+    "${CMAKE_CURRENT_BINARY_DIR}/avopkg" @ONLY)
+  install(FILES
+    "${CMAKE_CURRENT_BINARY_DIR}/avopkg"
+    DESTINATION ${BIN_INSTALL_DIR}
+    PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE
+    WORLD_READ WORLD_EXECUTE)
+endif()
+
+# .prf file for QMake projects
+configure_file(
+  "${CMAKE_CURRENT_SOURCE_DIR}/avogadro.prf.in"
+  "${CMAKE_CURRENT_BINARY_DIR}/avogadro.prf" @ONLY)
+
+option(INSTALL_QMAKE_PRF "Install QMake integration files to Qt prefix" ON)
+if(QT_MKSPECS_DIR AND INSTALL_QMAKE_PRF)
+#  if ("${QT_MKSPECS_DIR}" MATCHES ^$"${CMAKE_INSTALL_PREFIX}/")
+#    string(REPLACE
+#      "${CMAKE_INSTALL_PREFIX}"
+#      ""
+#      QT_MKSPECS_RELATIVE
+#      "${QT_MKSPECS_DIR}"
+#    )
+    install(FILES
+      "${CMAKE_CURRENT_BINARY_DIR}/avogadro.prf"
+      DESTINATION "${CMAKE_INSTALL_PREFIX}/${QT_MKSPECS_RELATIVE}/features"
+    )
+#  endif ("${QT_MKSPECS_DIR}" MATCHES ^$"${CMAKE_INSTALL_PREFIX}/")
+else()
+  message(WARNING "Qt mkspecs directory not found. File 'avogadro.prf' will be installed to ${SHARE_INSTALL_PREFIX}/avogadro/qmake.")
+  install(FILES
+    "${CMAKE_CURRENT_BINARY_DIR}/avogadro.prf"
+    DESTINATION "${SHARE_INSTALL_PREFIX}/avogadro/qmake"
+  )
+endif()
+
+# Use CPack to do some of our packaging
+include(AvoCPack)
diff --git a/crystals/zeolites/CON.cif b/crystals/zeolites/CON.cif
deleted file mode 100644
index 3a7dfc3..0000000
--- a/crystals/zeolites/CON.cif
+++ /dev/null
@@ -1,69 +0,0 @@
-data_CON
-#**************************************************************************
-#
-# CIF taken from the IZA-SC Database of Zeolite Structures
-# Ch. Baerlocher and L.B. McCusker
-# Database of Zeolite Structures: http://www.iza-structure.org/databases/ 
-#
-# All data on this site have been placed in the public domain.
-# If you use this work in a scientific publication, you are obligated to
-# cite its origin.
-#
-# The atom coordinates and the cell parameters were optimized with DLS76
-# assuming a pure SiO2 composition.
-#
-#**************************************************************************
-
-_cell_length_a                  22.6840(0)
-_cell_length_b                  13.3730(0)
-_cell_length_c                  12.5530(0)
-_cell_angle_alpha               90.0000(0)
-_cell_angle_beta                69.4790(0)
-_cell_angle_gamma               90.0000(0)
-
-_symmetry_space_group_name_H-M     'C 2/m'
-_symmetry_Int_Tables_number         12
-_symmetry_cell_setting             monoclinic
-
-loop_
-_symmetry_equiv_pos_as_xyz
-'+x,+y,+z'
-'1/2+x,1/2+y,+z'
-'-x,+y,-z'
-'1/2-x,1/2+y,-z'
-'-x,-y,-z'
-'1/2-x,1/2-y,-z'
-'+x,-y,+z'
-'1/2+x,1/2-y,+z'
-
-loop_
-_atom_site_label
-_atom_site_type_symbol
-_atom_site_fract_x
-_atom_site_fract_y
-_atom_site_fract_z
-    O1    O     0.0000    0.1506    0.5000
-    O2    O     0.0796    0.0000    0.4485
-    O3    O     0.1196    0.1818    0.3823
-    O4    O     0.0846    0.1341    0.5984
-    O5    O     0.2219    0.1292    0.2129
-    O6    O     0.1805    0.3139    0.2277
-    O7    O     0.1177    0.1690    0.1745
-    O8    O     0.1177    0.1867    0.7715
-    O9    O     0.0002    0.1388    0.8051
-   O10    O     0.0878    0.0000    0.7495
-   O11    O     0.3070    0.0000    0.0941
-   O12    O     0.2695    0.1444    0.9903
-   O13    O     0.3393    0.1863    0.1132
-   O14    O     0.2928    0.0000    0.8390
-   O15    O     0.2016    0.1280    0.8592
-   O16    O     0.0850    0.0000    0.1035
-   O17    O     0.0857    0.1671    0.9928
-    T1    Si    0.0709    0.1165    0.4825
-    T2    Si    0.1598    0.1983    0.2496
-    T3    Si    0.0725    0.1149    0.7310
-    T4    Si    0.2845    0.1148    0.1026
-    T5    Si    0.2708    0.1146    0.8653
-    T6    Si    0.0719    0.1184    0.1166
-    T7    Si    0.1415    0.1990    0.8776
-
diff --git a/libavogadro/src/extensions/surfaces/openqube/gaussianset.h b/libavogadro/src/extensions/surfaces/openqube/gaussianset.h
index 8e415ed..3cd1cb1 100644
--- a/libavogadro/src/extensions/surfaces/openqube/gaussianset.h
+++ b/libavogadro/src/extensions/surfaces/openqube/gaussianset.h
@@ -17,7 +17,9 @@
 
 #ifndef GAUSSIANSET_H
 #define GAUSSIANSET_H
-
+#ifndef M_PI
+    #define M_PI 3.14159265358979323846
+#endif
 #include "config.h"
 
 #include "basisset.h"
diff --git a/libavogadro/src/extensions/surfaces/openqube/gaussianset.h~ b/libavogadro/src/extensions/surfaces/openqube/gaussianset.h~
new file mode 100644
index 0000000..8e415ed
--- /dev/null
+++ b/libavogadro/src/extensions/surfaces/openqube/gaussianset.h~
@@ -0,0 +1,241 @@
+/******************************************************************************
+
+  This source file is part of the OpenQube project.
+
+  Copyright 2008-2010 Marcus D. Hanwell
+  Copyright 2008 Albert De Fusco
+
+  This source code is released under the New BSD License, (the "License").
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+
+******************************************************************************/
+
+#ifndef GAUSSIANSET_H
+#define GAUSSIANSET_H
+
+#include "config.h"
+
+#include "basisset.h"
+
+#include <QtCore/QFuture>
+
+#include <Eigen/Core>
+#include <vector>
+
+#include <QTextStream>
+
+namespace OpenQube
+{
+
+struct GaussianShell;
+
+/**
+ * Enumeration of the Gaussian type orbitals.
+ */
+ enum orbital { S, SP, P, D, D5, F, F7, G, G9, H, H11, I, I13, UU };
+
+/**
+ * @class GaussianSet gaussianset.h
+ * @brief GaussianSet Class
+ * @author Marcus D. Hanwell
+ *
+ * The GaussianSet class has a transparent data structure for storing the basis
+ * sets output by many quantum mechanical codes. It has a certain hierarchy
+ * where shells are built up from n primitives, in this case Gaussian Type
+ * Orbitals (GTOs). Each shell has a type (S, P, D, F, etc) and is composed of
+ * one or more GTOs. Each GTO has a contraction coefficient, c, and an exponent,
+ * a.
+ *
+ * When calculating Molecular Orbitals (MOs) each orthogonal shell has an
+ * independent coefficient. That is the S type orbitals have one coefficient,
+ * the P type orbitals have three coefficients (Px, Py and Pz), the D type
+ * orbitals have five (or six if cartesian types) coefficients, and so on.
+ */
+
+class OPENQUBE_EXPORT GaussianSet : public BasisSet
+{
+  Q_OBJECT
+
+public:
+  /**
+   * Constructor.
+   */
+  GaussianSet();
+
+  /**
+   * Destructor.
+   */
+  ~GaussianSet();
+
+  /**
+   * Function to add an atom to the GaussianSet.
+   * @param pos Position of the center of the QAtom.
+   * @param num The atomic number of the QAtom.
+   * @return The index of the added atom.
+   */
+  unsigned int addAtom(const Eigen::Vector3d& pos, int num = 0);
+
+  /**
+   * Add a basis to the basis set.
+   * @param atom Index of the atom to add the Basis too.
+   * @param type The type of the Basis being added.
+   * @return The index of the added Basis.
+   */
+  unsigned int addBasis(unsigned int atom, orbital type);
+
+  /**
+   * Add a GTO to the supplied basis.
+   * @param basis The index of the Basis to add the GTO to.
+   * @param c The contraction coefficient of the GTO.
+   * @param a The exponent of the GTO.
+   * @return The index of the added GTO.
+   */
+  unsigned int addGTO(unsigned int basis, double c, double a);
+
+  /**
+   * Add MO coefficients to the GaussianSet.
+   * @param MOs Vector containing the MO coefficients for the GaussianSet.
+   */
+  void addMOs(const std::vector<double>& MOs);
+
+  /**
+   * Add an individual MO coefficient.
+   * @param MO The MO coefficient.
+   */
+  void addMO(double MO);
+
+  /**
+   * Set the SCF density matrix for the GaussianSet.
+   */
+  bool setDensityMatrix(const Eigen::MatrixXd &m);
+
+  /**
+   * Debug routine, outputs all of the data in the GaussianSet.
+   */
+  void outputAll();
+
+  /**
+   * @return The number of MOs in the GaussianSet.
+   */
+  unsigned int numMOs();
+
+  /**
+   * Calculate the MO over the entire range of the supplied Cube.
+   * @param cube The cube to write the values of the MO into.
+   * @note This function starts a threaded calculation. Use watcher()
+   * to monitor progress.
+   * @sa BasisSet::blockingCalculateCubeMO
+   * @return True if the calculation was successful.
+   */
+  bool calculateCubeMO(Cube *cube, unsigned int state = 1);
+
+  /**
+   * Calculate the electron density over the entire range of the supplied Cube.
+   * @param cube The cube to write the values of the MO into.
+   * @note This function starts a threaded calculation. Use watcher()
+   * to monitor progress.
+   * @sa blockingCalculateCubeDensity
+   * @return True if the calculation was successful.
+   */
+  bool calculateCubeDensity(Cube *cube);
+
+  /**
+   * When performing a calculation the QFutureWatcher is useful if you want
+   * to update a progress bar.
+   */
+  QFutureWatcher<void> & watcher() { return m_watcher; }
+
+  /**
+   * Create a deep copy of @a this and return a pointer to it.
+   */
+  virtual BasisSet * clone();
+
+signals:
+  /**
+   * Emitted when the calculation is complete.
+   */
+  void finished();
+
+private slots:
+  /**
+   * Slot to set the cube data once Qt Concurrent is done
+   */
+  void calculationComplete();
+
+private:
+  // New storage of the data
+  std::vector<int> m_symmetry;             //! Symmetry of the basis, S, P...
+  std::vector<unsigned int> m_atomIndices; //! Indices into the atomPos vector
+  std::vector<unsigned int> m_moIndices;   //! Indices into the MO/density matrix
+  std::vector<unsigned int> m_gtoIndices;  //! Indices into the GTO vector
+  std::vector<unsigned int> m_cIndices;    //! Indices into m_gtoCN
+  std::vector<double> m_gtoA;              //! The GTO exponent
+  std::vector<double> m_gtoC;              //! The GTO contraction coefficient
+  std::vector<double> m_gtoCN;             //! The GTO contraction coefficient (normalized)
+  Eigen::MatrixXd m_moMatrix;              //! MO coefficient matrix
+  Eigen::MatrixXd m_density;               //! Density matrix
+
+  unsigned int m_numMOs;    //! The number of GTOs
+  unsigned int m_numAtoms;  //! Total number of atoms in the basis set
+  bool m_init;              //! Has the calculation been initialised?
+
+  QFuture<void> m_future;
+  QFutureWatcher<void> m_watcher;
+  Cube *m_cube; //! Cube to put the results into
+  QVector<GaussianShell> *m_gaussianShells;
+
+  static bool isSmall(double val);
+
+  void initCalculation();  //! Perform initialisation before any calculations
+  /// Re-entrant single point forms of the calculations
+  static void processPoint(GaussianShell &shell);
+  static void processDensity(GaussianShell &shell);
+  static double pointS(GaussianSet *set, unsigned int moIndex,
+                       double dr2, unsigned int indexMO);
+  static double pointP(GaussianSet *set, unsigned int moIndex,
+                       const Eigen::Vector3d &delta,
+                       double dr2, unsigned int indexMO);
+  static double pointD(GaussianSet *set, unsigned int moIndex,
+                       const Eigen::Vector3d &delta,
+                       double dr2, unsigned int indexMO);
+  static double pointD5(GaussianSet *set, unsigned int moIndex,
+                        const Eigen::Vector3d &delta,
+                        double dr2, unsigned int indexMO);
+  static double pointF(GaussianSet *set, unsigned int moIndex,
+                        const Eigen::Vector3d &delta,
+                        double dr2, unsigned int indexMO);
+  static double pointF7(GaussianSet *set, unsigned int moIndex,
+                        const Eigen::Vector3d &delta,
+                        double dr2, unsigned int indexMO);
+  static double pointG9(GaussianSet *set, unsigned int moIndex,
+                        const Eigen::Vector3d &delta,
+                        double dr2, unsigned int indexMO);
+  static double pointH11(GaussianSet *set, unsigned int moIndex,
+                        const Eigen::Vector3d &delta,
+                        double dr2, unsigned int indexMO);
+  static double pointI13(GaussianSet *set, unsigned int moIndex,
+                        const Eigen::Vector3d &delta,
+                        double dr2, unsigned int indexMO);
+  /// Calculate the basis for the density
+  static void pointS(GaussianSet *set, double dr2, int basis,
+                     Eigen::MatrixXd &out);
+  static void pointP(GaussianSet *set, const Eigen::Vector3d &delta,
+                     double dr2, int basis, Eigen::MatrixXd &out);
+  static void pointD(GaussianSet *set, const Eigen::Vector3d &delta,
+                     double dr2, int basis, Eigen::MatrixXd &out);
+  static void pointD5(GaussianSet *set, const Eigen::Vector3d &delta,
+                      double dr2, int basis, Eigen::MatrixXd &out);
+  static void pointF(GaussianSet *set, const Eigen::Vector3d &delta,
+                      double dr2, int basis, Eigen::MatrixXd &out);
+  static void pointF7(GaussianSet *set, const Eigen::Vector3d &delta,
+                      double dr2, int basis, Eigen::MatrixXd &out);
+};
+
+} // End namespace
+
+#endif
diff --git a/libavogadro/src/extensions/surfaces/orbitalwidget.h b/libavogadro/src/extensions/surfaces/orbitalwidget.h
index 80d4855..551fe7e 100644
--- a/libavogadro/src/extensions/surfaces/orbitalwidget.h
+++ b/libavogadro/src/extensions/surfaces/orbitalwidget.h
@@ -21,6 +21,8 @@
 
 #include <QtGui/QWidget>
 
+
+
 #include <avogadro/primitive.h>
 #include <avogadro/glwidget.h>
 
diff --git a/libavogadro/src/extensions/surfaces/orbitalwidget.h~ b/libavogadro/src/extensions/surfaces/orbitalwidget.h~
new file mode 100644
index 0000000..ea5bb97
--- /dev/null
+++ b/libavogadro/src/extensions/surfaces/orbitalwidget.h~
@@ -0,0 +1,105 @@
+/**********************************************************************
+  OrbitalExtension - Molecular orbital explorer
+
+  Copyright (C) 2010 by David C. Lonie
+
+  This file is part of the Avogadro molecular editor project.
+  For more information, see <http://avogadro.cc/>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation version 2 of the License.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+ ***********************************************************************/
+
+#ifndef ORBITALWIDGET_H
+#define ORBITALWIDGET_H
+
+#include <QtGui/QWidget>
+
+#include <QtGui/QItemSelection>
+
+#include <avogadro/primitive.h>
+#include <avogadro/glwidget.h>
+
+#include "orbitalextension.h"
+#include "orbitaltablemodel.h"
+
+#include "ui_orbitalwidget.h"
+
+namespace Avogadro {
+  class OrbitalSettingsDialog;
+  class OrbitalTableModel;
+
+  class OrbitalWidget : public QWidget
+  {
+      Q_OBJECT
+
+    public:
+
+      enum OrbitalQuality {
+        OQ_Low = 0,
+        OQ_Medium,
+        OQ_High,
+        OQ_VeryHigh
+      };
+
+      //! Constructor
+      explicit OrbitalWidget( QWidget *parent = 0, Qt::WindowFlags f = 0 );
+      //! Deconstructor
+      virtual ~OrbitalWidget();
+
+      double isovalue() {return m_isovalue;};
+      OrbitalQuality defaultQuality() {return m_quality;};
+
+      bool precalcLimit() {return m_precalc_limit;}
+      int precalcRange() {return m_precalc_range;}
+
+      static double OrbitalQualityToDouble(OrbitalQuality q);
+      static double OrbitalQualityToDouble(int i) {
+        return OrbitalQualityToDouble(OrbitalQuality(i));};
+
+    public slots:
+      void readSettings();
+      void writeSettings();
+      void reject();
+      void fillTable(QList<Orbital> list);
+      void setQuality(OrbitalQuality q);
+      void selectOrbital(unsigned int orbital);
+      void setDefaults(OrbitalWidget::OrbitalQuality quality, double isovalue, bool HOMOFirst);
+      void setPrecalcSettings(bool limit, int range);
+      void initializeProgress(int orbital, int min, int max, int stage, int totalStages);
+      void nextProgressStage(int orbital, int newmin, int newmax);
+      void updateProgress(int orbital, int current);
+      void calculationComplete(int orbital);
+      void calculationQueued(int orbital);
+
+    signals:
+      void orbitalSelected(unsigned int orbital);
+      void renderRequested(unsigned int orbital, double resolution);
+      void calculateAll();
+
+    private slots:
+      void tableClicked(const QItemSelection&);
+      void renderClicked();
+      void configureClicked();
+
+    private:
+      Ui::OrbitalWidget ui;
+      OrbitalSettingsDialog *m_settings;
+      OrbitalQuality m_quality;
+      double m_isovalue;
+
+      bool m_precalc_limit;
+      int m_precalc_range;
+
+      OrbitalTableModel *m_tableModel;
+      OrbitalSortingProxyModel *m_sortedTableModel;
+  };
+}
+
+#endif
diff --git a/libavogadro/src/extensions/swcntbuilder/tubegen/ANSR.h b/libavogadro/src/extensions/swcntbuilder/tubegen/ANSR.h
index 245ad82..038462b 100755
--- a/libavogadro/src/extensions/swcntbuilder/tubegen/ANSR.h
+++ b/libavogadro/src/extensions/swcntbuilder/tubegen/ANSR.h
@@ -18,18 +18,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#ifdef _MSC_VER
-typedef __int8 int8_t;
-typedef unsigned __int8 uint8_t;
-typedef __int16 int16_t;
-typedef unsigned __int16 uint16_t;
-typedef __int32 int32_t;
-typedef unsigned __int32 uint32_t;
-typedef __int64 int64_t;
-typedef unsigned __int64 uint64_t;
-#else
 #include <stdint.h>
-#endif
+
 
 using namespace std;
 
diff --git a/libavogadro/src/extensions/swcntbuilder/tubegen/Bitmap.h b/libavogadro/src/extensions/swcntbuilder/tubegen/Bitmap.h
index f414a71..9f54524 100644
--- a/libavogadro/src/extensions/swcntbuilder/tubegen/Bitmap.h
+++ b/libavogadro/src/extensions/swcntbuilder/tubegen/Bitmap.h
@@ -21,18 +21,8 @@
 // Replaced with:
 #include <stdlib.h>
 #include <stdio.h>
-#ifdef _MSC_VER
-typedef __int8 int8_t;
-typedef unsigned __int8 uint8_t;
-typedef __int16 int16_t;
-typedef unsigned __int16 uint16_t;
-typedef __int32 int32_t;
-typedef unsigned __int32 uint32_t;
-typedef __int64 int64_t;
-typedef unsigned __int64 uint64_t;
-#else
 #include <stdint.h>
-#endif
+
 
 #if defined(__cplusplus)
 extern "C" {
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/context.c b/libavogadro/src/extensions/symmetry/libmsym/src/context.c
index 46b48dd..ca06b96 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/context.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/context.c
@@ -118,7 +118,7 @@ err:
 }
 
 
-msym_error_t msymSetElements(msym_context ctx, int length, msym_element_t elements[length]){
+msym_error_t msymSetElements(msym_context ctx, int length, msym_element_t elements[]){
     msym_error_t ret = MSYM_SUCCESS;
     msym_thresholds_t *thresholds = NULL;
     struct {msym_orbital_t *s; msym_orbital_t *e;} aorb = {.s= NULL, .e = NULL} ;
@@ -127,8 +127,8 @@ msym_error_t msymSetElements(msym_context ctx, int length, msym_element_t elemen
     
     if(MSYM_SUCCESS != (ret = msymGetThresholds(ctx, &thresholds))) goto err;
     
-    ctx->elements = malloc(sizeof(msym_element_t[length]));
-    ctx->pelements = malloc(sizeof(msym_element_t *[length]));
+    ctx->elements = malloc(sizeof(msym_element_t)*length);
+    ctx->pelements = malloc(sizeof(msym_element_t *)*length);
     
     for(int i = 0; i < length;i++){
         ctx->pelements[i] = &ctx->elements[i];
@@ -201,16 +201,16 @@ msym_error_t msymGetElements(msym_context ctx, int *length, msym_element_t **ele
     msym_element_t *relements = NULL;
     if(ctx == NULL) {ret = MSYM_INVALID_CONTEXT;goto err;}
     if(ctx->elements == NULL) {ret = MSYM_INVALID_ELEMENTS;goto err;}
-    if(ctx->ext.elements == NULL) ctx->ext.elements = malloc(sizeof(msym_element_t[ctx->el]));
+    if(ctx->ext.elements == NULL) ctx->ext.elements = malloc(sizeof(msym_element_t)*ctx->el);
     if(ctx->orbitals != NULL) {
-        if(ctx->ext.orbitals == NULL) ctx->ext.orbitals = malloc(sizeof(msym_orbital_t[ctx->ol]));
-        memcpy(ctx->ext.orbitals,ctx->orbitals,sizeof(msym_orbital_t[ctx->ol]));
+        if(ctx->ext.orbitals == NULL) ctx->ext.orbitals = malloc(sizeof(msym_orbital_t)*ctx->ol);
+        memcpy(ctx->ext.orbitals,ctx->orbitals,sizeof(msym_orbital_t)*ctx->ol);
     }
     if(ctx->porbitals != NULL){
         if(ctx->ext.porbitals == NULL) ctx->ext.orbitals = calloc(ctx->ol,sizeof(msym_orbital_t*));
     }
     
-    memcpy(ctx->ext.elements,ctx->elements,sizeof(msym_element_t[ctx->el]));
+    memcpy(ctx->ext.elements,ctx->elements,sizeof(msym_element_t)*ctx->el);
     msym_orbital_t **porb = ctx->ext.porbitals;
     for(msym_element_t *a = ctx->ext.elements; a < (ctx->ext.elements+ctx->el); a++){
         vadd(a->v,ctx->cm,a->v);
@@ -259,7 +259,7 @@ err:
 }
 
 
-msym_error_t msymGetPointGroup(msym_context ctx, int l, char buf[l]){
+msym_error_t msymGetPointGroup(msym_context ctx, int l, char buf[]){
     msym_error_t ret = MSYM_SUCCESS;
     if(ctx == NULL) {ret = MSYM_INVALID_CONTEXT;goto err;}
     if(ctx->pg == NULL) {ret = MSYM_INVALID_POINT_GROUP;goto err;}
@@ -290,10 +290,10 @@ msym_error_t msymGetSubgroups(msym_context ctx, int *sgl, msym_subgroup_t **sg){
     }
     
     if(ctx->ext.sg == NULL){
-        ctx->ext.sg = malloc(sizeof(msym_subgroup_t[ctx->sgl]));
-        memcpy(ctx->ext.sg, ctx->sg, sizeof(msym_subgroup_t[ctx->sgl]));
+        ctx->ext.sg = malloc(sizeof(msym_subgroup_t)*ctx->sgl);
+        memcpy(ctx->ext.sg, ctx->sg, sizeof(msym_subgroup_t)*ctx->sgl);
         for(int i = 0;i < ctx->sgl;i++){
-            ctx->ext.sg[i].sops = malloc(sizeof(msym_symmetry_operation_t *[ctx->sg[i].sopsl]));
+            ctx->ext.sg[i].sops = malloc(sizeof(msym_symmetry_operation_t *)*ctx->sg[i].sopsl);
             for(int j = 0;j < ctx->sg[i].sopsl;j++){
                 ctx->ext.sg[i].sops[j] = ctx->sg[i].sops[j] - ctx->pg->sops + ctx->ext.sops;
                 ctx->ext.sg[i].subgroup[0] = ctx->sg[i].subgroup[0] == NULL ? NULL : ctx->sg[i].subgroup[0] - ctx->sg + ctx->ext.sg;
@@ -372,8 +372,8 @@ msym_error_t msymGetSymmetryOperations(msym_context ctx, int *sopsl, msym_symmet
     msym_symmetry_operation_t *rsops = NULL;
     if(ctx == NULL) {ret = MSYM_INVALID_CONTEXT;goto err;}
     if(ctx->pg == NULL || ctx->pg->sops == NULL) {ret = MSYM_INVALID_POINT_GROUP;goto err;}
-    if(ctx->ext.sops == NULL) ctx->ext.sops = malloc(sizeof(msym_symmetry_operation_t[ctx->pg->sopsl]));
-    memcpy(ctx->ext.sops,ctx->pg->sops,sizeof(msym_symmetry_operation_t[ctx->pg->sopsl]));
+    if(ctx->ext.sops == NULL) ctx->ext.sops = malloc(sizeof(msym_symmetry_operation_t)*ctx->pg->sopsl);
+    memcpy(ctx->ext.sops,ctx->pg->sops,sizeof(msym_symmetry_operation_t)*ctx->pg->sopsl);
     *sops = ctx->ext.sops;
     *sopsl = ctx->pg->sopsl;
     return ret;
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.c b/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.c
index 6bd69e5..3f6e12a 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.c
@@ -19,20 +19,20 @@
 
 #define SQR(x) ((x)*(x))
 
-msym_error_t partitionEquivalenceSets(int length, msym_element_t *elements[length], msym_element_t *pelements[length], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
-msym_error_t partitionPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[length], msym_element_t *pelements[length], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
+msym_error_t partitionEquivalenceSets(int length, msym_element_t *elements[], msym_element_t *pelements[], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
+msym_error_t partitionPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[], msym_element_t *pelements[], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
 
 
 
-msym_error_t copyEquivalenceSets(int length, msym_equivalence_set_t es[length], msym_equivalence_set_t **ces){
+msym_error_t copyEquivalenceSets(int length, msym_equivalence_set_t es[], msym_equivalence_set_t **ces){
     msym_error_t ret = MSYM_SUCCESS;
     int el = 0;
     
     for(int i = 0;i < length;i++) el += es[i].length;
-    msym_equivalence_set_t *nes = malloc(sizeof(msym_equivalence_set_t[length]) + sizeof(msym_element_t *[el]));
+    msym_equivalence_set_t *nes = malloc(sizeof(msym_equivalence_set_t)*length + sizeof(msym_element_t *)*el);
     msym_element_t **ep = (msym_element_t **) &es[length];
     msym_element_t **nep = (msym_element_t **) &nes[length];
-    memcpy(nes, es, sizeof(msym_equivalence_set_t[length]) + sizeof(msym_element_t *[el]));
+    memcpy(nes, es, sizeof(msym_equivalence_set_t)*length + sizeof(msym_element_t *)*el);
     for(int i = 0;i < length;i++) nes[i].elements = nes[i].elements - ep + nep;
     *ces = nes;
 err:
@@ -40,9 +40,9 @@ err:
 }
 
 //TODO: Use a preallocated pointer array instead of multiple mallocs
-msym_error_t generateEquivalenceSet(msym_point_group_t *pg, int length, msym_element_t elements[length], int *glength, msym_element_t **gelements, int *esl, msym_equivalence_set_t **es,msym_thresholds_t *thresholds){
+msym_error_t generateEquivalenceSet(msym_point_group_t *pg, int length, msym_element_t elements[], int *glength, msym_element_t **gelements, int *esl, msym_equivalence_set_t **es,msym_thresholds_t *thresholds){
     msym_error_t ret = MSYM_SUCCESS;
-    msym_element_t *ge = calloc(length,sizeof(msym_element_t[pg->order]));
+    msym_element_t *ge = calloc(length,sizeof(msym_element_t)*pg->order);
     msym_equivalence_set_t *ges = calloc(length,sizeof(msym_equivalence_set_t));
     int gel = 0;
     int gesl = 0;
@@ -89,12 +89,12 @@ msym_error_t generateEquivalenceSet(msym_point_group_t *pg, int length, msym_ele
             goto err;
         }
         
-        aes->elements = realloc(aes->elements,sizeof(msym_element_t*[aes->length]));
+        aes->elements = realloc(aes->elements,sizeof(msym_element_t*)*aes->length);
     }
     
     msym_element_t *geo = ge;
-    ge = realloc(ge,sizeof(msym_element_t[gel]));
-    ges = realloc(ges,sizeof(msym_equivalence_set_t[gesl]) + sizeof(msym_element_t *[gel]));
+    ge = realloc(ge,sizeof(msym_element_t)*gel);
+    ges = realloc(ges,sizeof(msym_equivalence_set_t)*gesl + sizeof(msym_element_t *)*gel);
     
     msym_element_t **ep = (msym_element_t **) &ges[gesl];
     for(int i = 0;i < gesl;i++){
@@ -120,7 +120,7 @@ err:
     return ret;
 }
 
-msym_error_t splitPointGroupEquivalenceSets(msym_point_group_t *pg, int esl, msym_equivalence_set_t es[esl], int *sesl, msym_equivalence_set_t **ses, msym_thresholds_t *thresholds){
+msym_error_t splitPointGroupEquivalenceSets(msym_point_group_t *pg, int esl, msym_equivalence_set_t es[], int *sesl, msym_equivalence_set_t **ses, msym_thresholds_t *thresholds){
     msym_error_t ret = MSYM_SUCCESS;
     int length = 0, gesl = 0;
     for(int i = 0;i < esl;i++) length += es[i].length;
@@ -132,15 +132,15 @@ msym_error_t splitPointGroupEquivalenceSets(msym_point_group_t *pg, int esl, msy
         msym_equivalence_set_t *pes = NULL;
         int pesl = 0;
         if(MSYM_SUCCESS != (ret = partitionPointGroupEquivalenceSets(pg, es[i].length, es[i].elements, es[i].elements - ep + pelements, &pesl, &pes, thresholds))) goto err;
-        ges = realloc(ges, sizeof(msym_equivalence_set_t[gesl+pesl]));
-        memcpy(&ges[gesl], pes, sizeof(msym_equivalence_set_t[pesl]));
+        ges = realloc(ges, sizeof(msym_equivalence_set_t)*(gesl+pesl));
+        memcpy(&ges[gesl], pes, sizeof(msym_equivalence_set_t)*pesl);
         free(pes);
         gesl += pesl;
     }
     
-    ges = realloc(ges, sizeof(msym_equivalence_set_t[gesl]) + sizeof(msym_element_t *[length]));
+    ges = realloc(ges, sizeof(msym_equivalence_set_t)*gesl + sizeof(msym_element_t *)*length);
     ep = (msym_element_t **) &ges[gesl];
-    memcpy(ep, pelements, sizeof(msym_element_t *[length]));
+    memcpy(ep, pelements, sizeof(msym_element_t *)*length);
     
     for(int i = 0;i < gesl;i++){
         ges[i].elements = ep;
@@ -158,17 +158,17 @@ err:
     return ret;
 }
 
-msym_error_t findPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[length], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds){
+msym_error_t findPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds){
     msym_error_t ret = MSYM_SUCCESS;
     msym_equivalence_set_t *ges = NULL;
     msym_element_t **pelements = calloc(length,sizeof(msym_element_t*));
     int gesl = 0;
     if(MSYM_SUCCESS != (ret = partitionPointGroupEquivalenceSets(pg, length, elements, pelements, &gesl, &ges, thresholds))) goto err;
     
-    ges = realloc(ges,sizeof(msym_equivalence_set_t[gesl]) + sizeof(msym_element_t *[length]));
+    ges = realloc(ges,sizeof(msym_equivalence_set_t)*gesl + sizeof(msym_element_t *)*length);
     msym_element_t **ep = (msym_element_t **) &ges[gesl];
     msym_element_t **epo = ep;
-    memcpy(ep, pelements, sizeof(msym_element_t *[length]));
+    memcpy(ep, pelements, sizeof(msym_element_t *)*length);
     for(int i = 0;i < gesl;i++){
         if(ep > epo + length){
             msymSetErrorDetails("Equivalence set pointer (%ld) extends beyond number of elements (%d)",ep-epo,length);
@@ -190,11 +190,11 @@ err:
 
 }
 
-msym_error_t partitionPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[length], msym_element_t *pelements[length], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds){
+msym_error_t partitionPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[], msym_element_t *pelements[], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds){
     msym_error_t ret = MSYM_SUCCESS;
     msym_equivalence_set_t *ges = calloc(length,sizeof(msym_equivalence_set_t));
-    int *eqi = malloc(sizeof(int[length]));
-    memset(eqi,-1,sizeof(int[length]));
+    int *eqi = malloc(sizeof(int)*length);
+    memset(eqi,-1,sizeof(int)*length);
     int gesl = 0, pelementsl = 0;
     for(int i = 0;i < length;i++){
         if(eqi[i] >= 0) continue;
@@ -258,7 +258,7 @@ err:
 
 }
 
-msym_error_t findEquivalenceSets(int length, msym_element_t *elements[length], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds) {
+msym_error_t findEquivalenceSets(int length, msym_element_t *elements[], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds) {
     msym_error_t ret = MSYM_SUCCESS;
     int sesl = 0;
     msym_equivalence_set_t *ses = NULL;
@@ -275,8 +275,8 @@ msym_error_t findEquivalenceSets(int length, msym_element_t *elements[length], m
             if(rsesl > 1){
                 ses[i].elements = rses[0].elements;
                 ses[i].length = rses[0].length;
-                ses = realloc(ses, sizeof(msym_equivalence_set_t[sesl+rsesl-1]));
-                memcpy(&ses[sesl], &rses[1], sizeof(msym_equivalence_set_t[rsesl-1]));
+                ses = realloc(ses, sizeof(msym_equivalence_set_t)*(sesl + rsesl - 1));
+                memcpy(&ses[sesl], &rses[1], sizeof(msym_equivalence_set_t)*(rsesl-1));
                 sesl += rsesl-1;
                 i--;
             }
@@ -284,11 +284,11 @@ msym_error_t findEquivalenceSets(int length, msym_element_t *elements[length], m
         }
     }
 
-    ses = realloc(ses, sizeof(msym_equivalence_set_t[sesl]) + sizeof(msym_element_t *[length]));
+    ses = realloc(ses, sizeof(msym_equivalence_set_t)*sesl + sizeof(msym_element_t *)*length);
     msym_element_t **ep = (msym_element_t **) &ses[sesl];
     
     for(int i = 0;i < sesl;i++){
-        memcpy(ep, ses[i].elements, sizeof(msym_element_t *[ses[i].length]));
+        memcpy(ep, ses[i].elements, sizeof(msym_element_t *)*(ses[i].length));
         ses[i].elements = ep;
         ep += ses[i].length;
     }
@@ -305,7 +305,7 @@ err:
 }
 
 
-msym_error_t partitionEquivalenceSets(int length, msym_element_t *elements[length], msym_element_t *pelements[length], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds) {
+msym_error_t partitionEquivalenceSets(int length, msym_element_t *elements[], msym_element_t *pelements[], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds) {
     
     int ns = 0, gd = geometryDegenerate(g);
     double *e = calloc(length,sizeof(double));
@@ -414,8 +414,8 @@ msym_error_t partitionEquivalenceSets(int length, msym_element_t *elements[lengt
     msym_element_t **pe = pelements;
     
     if(elements == pelements){
-        lelements = malloc(sizeof(msym_element_t *[length]));
-        memcpy(lelements, elements, sizeof(msym_element_t *[length]));
+        lelements = malloc(sizeof(msym_element_t *)*length);
+        memcpy(lelements, elements, sizeof(msym_element_t *)*length);
     }
     
     for(int i = 0, ni = 0; i < length;i++){
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.h b/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.h
index ee3ce81..f4511cf 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.h
@@ -15,10 +15,10 @@
 #include "msym.h"
 #include "point_group.h"
 
-msym_error_t copyEquivalenceSets(int length, msym_equivalence_set_t es[length], msym_equivalence_set_t **ces);
-msym_error_t findEquivalenceSets(int length, msym_element_t *elements[length], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
-msym_error_t findPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[length], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
-msym_error_t splitPointGroupEquivalenceSets(msym_point_group_t *pg, int esl, msym_equivalence_set_t es[esl], int *sesl, msym_equivalence_set_t **ses, msym_thresholds_t *thresholds);
-msym_error_t generateEquivalenceSet(msym_point_group_t *pg, int length, msym_element_t elements[length], int *glength, msym_element_t **gelements, int *esl, msym_equivalence_set_t **es,msym_thresholds_t *thresholds);
+msym_error_t copyEquivalenceSets(int length, msym_equivalence_set_t *es, msym_equivalence_set_t **ces);
+msym_error_t findEquivalenceSets(int length, msym_element_t **elements, msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
+msym_error_t findPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t **elements, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
+msym_error_t splitPointGroupEquivalenceSets(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, int *sesl, msym_equivalence_set_t **ses, msym_thresholds_t *thresholds);
+msym_error_t generateEquivalenceSet(msym_point_group_t *pg, int length, msym_element_t *elements, int *glength, msym_element_t **gelements, int *esl, msym_equivalence_set_t **es,msym_thresholds_t *thresholds);
 
 #endif /* defined(__MSYM__EQUIVALENCE_SET_h) */
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/geometry.c b/libavogadro/src/extensions/symmetry/libmsym/src/geometry.c
index 56e9d68..4abce82 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/geometry.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/geometry.c
@@ -17,16 +17,16 @@
 
 #define SQR(x) ((x)*(x))
 
-void inertialTensor(int length, msym_element_t *elements[length], double cm[3], double e[3], double v[3][3], msym_thresholds_t *thresholds);
+void inertialTensor(int length, msym_element_t *elements[], double cm[3], double e[3], double v[3][3], msym_thresholds_t *thresholds);
 msym_geometry_t eigenvaluesToGeometry(double e[3], msym_thresholds_t *thresholds);
 
-msym_error_t findGeometry(int length, msym_element_t *elements[length], double cm[3], msym_thresholds_t *thresholds, msym_geometry_t *g, double e[3], double v[3][3]){
+msym_error_t findGeometry(int length, msym_element_t *elements[], double cm[3], msym_thresholds_t *thresholds, msym_geometry_t *g, double e[3], double v[3][3]){
     inertialTensor(length, elements, cm, e, v, thresholds);
     *g = eigenvaluesToGeometry(e,thresholds);
     return MSYM_SUCCESS;
 }
 
-msym_error_t findCenterOfMass(int length, msym_element_t *elements[length], double v[3]){
+msym_error_t findCenterOfMass(int length, msym_element_t *elements[], double v[3]){
     msym_error_t ret = MSYM_SUCCESS;
     double t = 0;
     v[0] = v[1] = v[2] = 0.0;
@@ -96,7 +96,7 @@ int geometryDegenerate(msym_geometry_t g){
     return !(g == PLANAR_IRREGULAR || g == ASSYMETRIC) && g != GEOMETRY_UNKNOWN;
 }
 
-void inertialTensor(int length, msym_element_t *elements[length], double cm[3], double e[3], double v[3][3], msym_thresholds_t *thresholds){
+void inertialTensor(int length, msym_element_t *elements[], double cm[3], double e[3], double v[3][3], msym_thresholds_t *thresholds){
     double Ixx = 0, Iyy = 0, Izz = 0, Ixy = 0, Ixz = 0, Iyz = 0;
     for(int i = 0; i < length; i++){
         msym_element_t *a = elements[i];
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/geometry.h b/libavogadro/src/extensions/symmetry/libmsym/src/geometry.h
index a3427bc..4d920fb 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/geometry.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/geometry.h
@@ -14,8 +14,8 @@
 #include <stdio.h>
 #include "msym.h"
 
-msym_error_t findGeometry(int length, msym_element_t *elements[length], double cm[3], msym_thresholds_t *thresholds, msym_geometry_t *g, double e[3], double v[3][3]);
-msym_error_t findCenterOfMass(int length, msym_element_t *elements[length], double v[3]);
+msym_error_t findGeometry(int length, msym_element_t **elements, double cm[3], msym_thresholds_t *thresholds, msym_geometry_t *g, double e[3], double v[3][3]);
+msym_error_t findCenterOfMass(int length, msym_element_t **elements, double v[3]);
 int geometryDegenerate(msym_geometry_t g);
 void printGeometry(msym_geometry_t g);
 
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/linalg.c b/libavogadro/src/extensions/symmetry/libmsym/src/linalg.c
index e2700ae..90298ee 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/linalg.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/linalg.c
@@ -24,9 +24,9 @@
 #define SQR(x) ((x)*(x))
 #define CUBE(x) ((x)*(x)*(x))
 
-void mleye(int l, double E[l][l]){
+void mleye(int l, double **E){
     
-    memset(E, 0, sizeof(double[l][l]));
+    memset(E, 0, sizeof(E));
     for(int i = 0;i < l;i++){
         E[i][i] = 1.0;
     }
@@ -181,7 +181,7 @@ void vproj(double v[3], double u[3], double vo[3]){
     vlproj(3, v, u, vo);
 }
 
-void vlproj(int l, double v[l], double u[l], double vo[l]){
+void vlproj(int l, double v[], double u[], double vo[]){
     vlscale(vldot(l,u,v)/vldot(l,u,u),l,u,vo);
 }
 
@@ -222,7 +222,7 @@ double vdot(double v1[3], double v2[3]) {
     
 }
 
-double vldot(int l, double v1[l], double v2[l]) {
+double vldot(int l, double v1[], double v2[]) {
     double d = 0;
     for(int i = 0; i < l; i++) d+= v1[i]*v2[i];
     return d;
@@ -234,7 +234,7 @@ void vadd(double v1[3],double v2[3], double vr[3]){
     vr[2] = v1[2] + v2[2];
 }
 
-void vladd(int l, double v1[l],double v2[l], double vr[l]){
+void vladd(int l, double v1[],double v2[], double vr[]){
     for(int i = 0; i < l;i++) vr[i] = v1[i] + v2[i];
 }
 
@@ -245,7 +245,7 @@ void vscale(double s,double v[3], double vr[3]){
     vr[2] = s*v[2];
 }
 
-void vlscale(double s,int l, double v[l], double vr[l]){
+void vlscale(double s,int l, double v[], double vr[]){
     for(int i = 0;i < l;i++) vr[i] = s*v[i];
 }
 
@@ -257,7 +257,7 @@ void mscale(double s,double m[3][3], double mr[3][3]){
     }
 }
 
-void mlscale(double s,int l, double m[l][l], double mr[l][l]){
+void mlscale(double s,int l, double **m, double **mr){
     for(int i=0; i<l; ++i){
         for(int j=0; j<l; ++j){
             mr[i][j] = s*m[i][j];
@@ -265,7 +265,7 @@ void mlscale(double s,int l, double m[l][l], double mr[l][l]){
     }
 }
 
-double mltrace(int l, double M[l][l]) {
+double mltrace(int l, double **M) {
     double trace = 0;
     for(int i = 0; i < l; i++) trace += M[i][i];
     return trace;
@@ -277,7 +277,7 @@ void vsub(double v1[3],double v2[3], double vr[3]){
     vr[2] = v1[2] - v2[2];
 }
 
-void vlsub(int l, double v1[l],double v2[l], double vr[l]){
+void vlsub(int l, double v1[],double v2[], double vr[]){
     for(int i = 0; i < l;i++) vr[i] = v1[i] - v2[i];
 }
 
@@ -285,7 +285,7 @@ double vabs(double v[3]){
     return sqrt(SQR(v[0])+SQR(v[1])+SQR(v[2]));
 }
 
-double vlabs(int l, double v[l]){
+double vlabs(int l, double v[]){
     double r = 0;
     for(int i = 0;i < l;i++) r += SQR(v[i]);
     return sqrt(r);
@@ -307,7 +307,7 @@ double vnorm(double v[3]){
     return norm;
 }
 
-double vlnorm(int l, double v[l]){
+double vlnorm(int l, double v[]){
     double norm = vlabs(l,v);
     if (norm != 0.0) {
         for(int i = 0; i < l;i++){
@@ -317,7 +317,7 @@ double vlnorm(int l, double v[l]){
     return norm;
 }
 
-double vlnorm2(int l, double v1[l], double v2[l]){
+double vlnorm2(int l, double v1[], double v2[]){
     double norm = vlabs(l,v1);
     if (norm != 0.0) {
         for(int i = 0; i < l;i++){
@@ -341,7 +341,7 @@ void vcopy(double vi[3], double vo[3]){
     vo[2] = vi[2];
 }
 
-void vlcopy(int l, double vi[l], double vo[l]){
+void vlcopy(int l, double vi[], double vo[]){
     for(int i = 0; i < l; i++) vo[i] = vi[i];
 }
 
@@ -355,8 +355,8 @@ void mvmul(double v[3], double m[3][3], double r[3]){
     r[2] = t[2];
 }
 
-void mvlmul(int r, int c, double M[r][c], double v[c], double vo[r]){
-    memset(vo, 0, sizeof(double[r]));
+void mvlmul(int r, int c, double **M, double v[], double vo[]){
+    memset(vo, 0, sizeof(vo));
     for(int i = 0; i < r; i++){
         for(int j = 0; j < c;j++){
             vo[i] += M[i][j]*v[j];
@@ -384,18 +384,18 @@ void mmmul(double A[3][3], double B[3][3], double C[3][3]){
     mcopy(T,C);
 }
 
-void mmtlmul(int rla, int cla, double A[rla][cla], int rlb, double B[rlb][cla], double C[rla][rlb]){
-    double (*T)[rlb] = malloc(sizeof(double[cla][rlb]));
+void mmtlmul(int rla, int cla, double **A, int rlb, double **B, double **C){
+    double (**T) = malloc(sizeof(double)*cla*rlb);
     mltranspose(rlb, cla, B, T);
     mmlmul(rla,cla,A,rlb,T,C);
     free(T);
 }
 
-void mmlmul(int rla, int cla, double A[rla][cla], int clb, double B[cla][clb], double C[rla][clb]){
+void mmlmul(int rla, int cla, double **A, int clb, double **B, double **C){
     
-    double (*T)[clb];
+    double (**T);
     if(A == C || B == C){
-        T = malloc(sizeof(double[rla][clb]));
+        T = malloc(sizeof(C));
     } else {
         T = C;
     }
@@ -430,7 +430,7 @@ int mequal(double A[3][3], double B[3][3], double t){
     return e;
 }
 
-void mlFilterSmall(int l, double A[l][l]){
+void mlFilterSmall(int l, double **A){
     for(int i = 0;i < l;i++){
         for(int j = 0;j < l;j++){
             if(fabs(A[i][j]) < DBL_EPSILON) A[i][j] = 0.0;
@@ -439,7 +439,7 @@ void mlFilterSmall(int l, double A[l][l]){
 }
 
 //only square matrixes for now
-void kron(int al, double A[al][al], int bl, double B[bl][bl], int cl, double C[cl][cl]){
+void kron(int al, double **A, int bl, double **B, int cl, double **C){
     for(int ai = 0; ai < al;ai++){
         for(int aj = 0; aj < al;aj++){
             for(int bi = 0; bi < bl;bi++){
@@ -451,7 +451,7 @@ void kron(int al, double A[al][al], int bl, double B[bl][bl], int cl, double C[c
     }
 }
 
-void vlprint(int l, double v[l]) {
+void vlprint(int l, double v[]) {
     printf("[");
     for(int i = 0;i < l;i++){
         printf("%lf%s",v[i],(i == (l - 1)) ? "]\n" : ";");
@@ -460,8 +460,8 @@ void vlprint(int l, double v[l]) {
 
 
 /* Graam-Schmidt */
-int mgs(int l, double M[l][l], double O[l][l], int n, double t){
-    double *tmp = malloc(sizeof(double[l]));
+int mgs(int l, double **M, double **O, int n, double t){
+    double *tmp = malloc(sizeof(double)*l);
     for(int i = 0; i < l;i++){
         if(vlabs(l,M[i]) < t){
             continue;
@@ -537,7 +537,7 @@ void madd(double A[3][3], double B[3][3], double C[3][3]){
     }
 }
 
-void mladd(int l, double A[l][l], double B[l][l], double C[l][l]){
+void mladd(int l, double **A, double **B, double **C){
     for(int i=0; i<l; ++i){
         for(int j=0; j<l; ++j){
             C[i][j] = A[i][j] + B[i][j];
@@ -580,7 +580,7 @@ void minv(double M[3][3], double I[3][3]){
     
 }
 
-void mlcopy(int l, double A[l][l], double B[l][l]){
+void mlcopy(int l, double **A, double **B){
     for(int i=0; i<l; ++i){
         for(int j=0; j<l; ++j){
             B[i][j] = A[i][j];
@@ -594,7 +594,7 @@ void mtranspose(double A[3][3], double B[3][3]){
 
 
 
-void mltranspose(int rl, int cl, double A[rl][cl], double B[cl][rl]){
+void mltranspose(int rl, int cl, double **A, double **B){
     for(int r = 0; r < rl;r++){
         for(int c = 0; c < cl;c++){
             B[c][r] = A[r][c];
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/linalg.h b/libavogadro/src/extensions/symmetry/libmsym/src/linalg.h
index aae52f8..358abf2 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/linalg.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/linalg.h
@@ -11,38 +11,38 @@
 #ifndef __MSYM_LINALG_h
 #define __MSYM_LINALG_h
 
-void mleye(int l, double E[l][l]);
+void mleye(int l, double **E);
 int vzero(double v[3], double t);
 int vparallel(double v1[3], double v2[3], double t);
 int vperpendicular(double v1[3], double v2[3], double t);
 double vnorm(double v[3]);
 double vnorm2(double v1[3],double v2[3]);
-double vlnorm(int l, double v[l]);
-double vlnorm2(int l, double v1[l], double v2[l]);
+double vlnorm(int l, double *v);
+double vlnorm2(int l, double *v1, double *v2);
 double vabs(double v[3]);
-double vlabs(int l, double v[l]);
+double vlabs(int l, double *v);
 void vinv(double v[3]);
 void vcopy(double vi[3], double vo[3]);
-void vlcopy(int l, double vi[l], double vo[l]);
+void vlcopy(int l, double *vi, double *vo);
 void vcross(double v1i[3],double v2i[3], double vr[3]);
 double vcrossnorm(double[3],double[3], double[3]);
 double vdot(double[3],double[3]);
-double vldot(int l, double v1[l], double v2[l]);
+double vldot(int l, double *v1, double *v2);
 int vequal(double v1[3],double v2[3], double t);
 void vadd(double[3],double[3], double[3]);
-void vladd(int l, double v1[l],double v2[l], double vr[l]);
+void vladd(int l, double *v1,double *v2, double *vr);
 void madd(double A[3][3], double B[3][3], double C[3][3]);
-void mladd(int l, double A[l][l], double B[l][l], double C[l][l]);
+void mladd(int l, double **A, double **B, double **C);
 void vsub(double[3],double[3], double[3]);
-void vlsub(int l, double v1[l],double v2[l], double vr[l]);
+void vlsub(int l, double *v1,double *v2, double *vr);
 void vscale(double,double[3], double[3]);
-void vlscale(double s,int l, double v[l], double vr[l]);
+void vlscale(double s,int l, double *v, double *vr);
 void mscale(double s,double m[3][3], double mr[3][3]);
-void mlscale(double s,int l, double m[l][l], double mr[l][l]);
+void mlscale(double s,int l, double **m, double **mr);
 void vproj_plane(double v[3], double plane[3], double proj[3]);
 void vproj(double v[3], double u[3], double vo[3]);
-void vlproj(int l, double v[l], double u[l], double vo[l]);
-void vlprint(int l, double v[l]);
+void vlproj(int l, double *v, double *u, double *vo);
+void vlprint(int l, double *v);
 void vcomplement(double v1[3], double v2[3]);
 double vangle(double[3],double[3]);
 void vrotate(double theta, double v[3], double axis[3], double vr[3]);
@@ -50,23 +50,23 @@ void mrotate(double theta, double axis[3], double m[3][3]);
 void vreflect(double v[3], double axis[3], double vr[3]);
 void mreflect(double axis[3], double m[3][3]);
 void mvmul(double v[3], double m[3][3], double r[3]);
-void mvlmul(int r, int c, double M[r][c], double v[c], double vo[r]);
+void mvlmul(int r, int c, double **M, double *v, double *vo);
 void mmmul(double A[3][3], double B[3][3], double C[3][3]);
-void mmlmul(int rla, int cla, double A[rla][cla], int clb, double B[cla][clb], double C[rla][clb]);
-void mmtlmul(int rla, int cla, double A[rla][cla], int rlb, double B[rlb][cla], double C[rla][rlb]);
+void mmlmul(int rla, int cla, double **A, int clb, double **B, double **C);
+void mmtlmul(int rla, int cla, double **A, int rlb, double **B, double **C);
 void minv(double M[3][3], double I[3][3]);
 double mdet(double M[3][3]);
 void mcopy(double A[3][3], double B[3][3]);
-void mlcopy(int l, double A[l][l], double B[l][l]);
+void mlcopy(int l, double **A, double **B);
 void mtranspose(double A[3][3], double B[3][3]);
-void mltranspose(int rl, int cl, double A[rl][cl], double B[cl][rl]);
-double mltrace(int l, double M[l][l]);
+void mltranspose(int rl, int cl, double **A, double **B);
+double mltrace(int l, double **M);
 int mequal(double A[3][3], double B[3][3], double t);
 void malign(double v[3], double axis[3], double m[3][3]);
 int ipow(int b, int e);
-int mgs(int l, double M[l][l], double O[l][l], int n, double t);
-void kron(int al, double A[al][al], int bl, double B[bl][bl], int cl, double C[cl][cl]);
-void mlFilterSmall(int l, double A[l][l]);
+int mgs(int l, double **M, double **O, int n, double t);
+void kron(int al, double **A, int bl, double **B, int cl, double **C);
+void mlFilterSmall(int l, double **A);
 void jacobi(double m[6], double e[3], double ev[3][3], double threshold);
 
 
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/msym.c b/libavogadro/src/extensions/symmetry/libmsym/src/msym.c
index 1fccdaa..9c8a6a2 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/msym.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/msym.c
@@ -109,7 +109,7 @@ err:
     return ret;
 }
 
-msym_error_t msymGenerateElements(msym_context ctx, int length, msym_element_t elements[length]){
+msym_error_t msymGenerateElements(msym_context ctx, int length, msym_element_t elements[]){
     msym_error_t ret = MSYM_SUCCESS;
     msym_point_group_t *pg = NULL;
     msym_thresholds_t *t = NULL;
@@ -475,7 +475,7 @@ err:
     return ret;
 }
 
-msym_error_t msymGetOrbitalSubspaces(msym_context ctx, int l, double c[l][l]){
+msym_error_t msymGetOrbitalSubspaces(msym_context ctx, int l, double **c){
     msym_error_t ret = MSYM_SUCCESS;
     msym_subspace_t *ss = NULL;
     msym_orbital_t *basis = NULL;
@@ -512,7 +512,7 @@ err:
 
 }
 
-msym_error_t msymSymmetrizeOrbitals(msym_context ctx, int l, double c[l][l]){
+msym_error_t msymSymmetrizeOrbitals(msym_context ctx, int l, double **c){
     msym_error_t ret = MSYM_SUCCESS;
 
     msym_point_group_t *pg = NULL;
@@ -521,7 +521,7 @@ msym_error_t msymSymmetrizeOrbitals(msym_context ctx, int l, double c[l][l]){
     msym_thresholds_t *t = NULL;
     int *span = NULL;
     
-    double (*symc)[l] = NULL;
+    double (**symc) = NULL;
     
     int ssl = 0, basisl = 0;
     
@@ -552,7 +552,7 @@ msym_error_t msymSymmetrizeOrbitals(msym_context ctx, int l, double c[l][l]){
     }
     
     
-    symc = malloc(sizeof(double[l][l]));
+    symc = malloc(sizeof(c));
     
     start = clock();
 
@@ -565,8 +565,8 @@ msym_error_t msymSymmetrizeOrbitals(msym_context ctx, int l, double c[l][l]){
     
     end = clock();
     
-    memcpy(c,symc,sizeof(double[l][l]));
-    
+    //memcpy(c,symc,sizeof(double[l][l]));
+	memcpy(c, symc, sizeof(c));
     time = (double)(end - start) / CLOCKS_PER_SEC;
     
     printf("time: %lf seconds to symmetrize %d orbitals\n",time,basisl);
@@ -620,7 +620,7 @@ msym_error_t msymFindEquivalenceSetPermutations(msym_context ctx) {
         }
     }*/
     
-    esv = malloc(sizeof(double (*[pg->order])[3]));
+    esv = malloc(sizeof(double (*)[3])*pg->order);
     for(int i = 0; i < esl;i++){
         for(int j = 0; j < es[i].length;j++){
             esv[j] = &es[i].elements[j]->v;
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/orbital.c b/libavogadro/src/extensions/symmetry/libmsym/src/orbital.c
index 143b4de..e67e60c 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/orbital.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/orbital.c
@@ -21,12 +21,12 @@
 #include "permutation.h"
 #include "point_group.h"
 
-void printTransform(int r, int c, double M[r][c]);
-void tabPrintTransform(int r, int c, double M[r][c],int indent);
+void printTransform(int r, int c, double **M);
+void tabPrintTransform(int r, int c, double **M,int indent);
 void printSubspaceTree(CharacterTable *ct, msym_subspace_t *ss,int indent);
 void tabprintf(char *format, int indent, ...);
 
-msym_error_t getOrbitalSubspaceCoefficients(msym_subspace_t *ss, int basisl, msym_orbital_t basis[basisl], int *offset, double c[basisl][basisl]);
+msym_error_t getOrbitalSubspaceCoefficients(msym_subspace_t *ss, int basisl, msym_orbital_t basis[], int *offset, double **c);
 int filterSubspace(msym_subspace_t *ss);
 
 
@@ -134,11 +134,17 @@ err:
 }
 
 //We can split this into a part for each l and just build the subspaces, and we already have the permutation matrix so
-msym_error_t findProjection(CharacterTable *ct, int sopsl, msym_symmetry_operation_t sops[sopsl], msym_permutation_t perm[sopsl], int l, msym_orbital_t *basis[2*l+1]){
+msym_error_t findProjection(CharacterTable *ct, int sopsl, msym_symmetry_operation_t sops[], msym_permutation_t perm[], int l, msym_orbital_t *basis[]){
     msym_error_t ret = MSYM_SUCCESS;
     int kdim = ipow(3,l), setl = perm[0].p_length;
-    double (*mkron)[kdim] = malloc(sizeof(double[kdim][kdim]));
-    double (*mperm)[setl] = malloc(sizeof(double[setl][setl]));
+	double(**mkron) = malloc(sizeof(double *) * kdim);
+	for (int i = 0; i < kdim; i++) {
+		mkron[i] = malloc(sizeof(double) * kdim);
+	}
+	double(**mperm) = malloc(sizeof(double *) * setl);
+	for (int i = 0; i < setl; i++) {
+		mperm[i] = malloc(sizeof(double) * setl);
+	}
     
     for(int m = 0; m < 2*l+1;m++){
         permutationMatrix(&perm[m], mperm);
@@ -149,11 +155,11 @@ msym_error_t findProjection(CharacterTable *ct, int sopsl, msym_symmetry_operati
     return ret;
 }
 
-msym_error_t generateOrbitalTransforms(int sopsl, msym_symmetry_operation_t sops[sopsl], int l, double transform[sopsl][2*l+1][2*l+1]){
+msym_error_t generateOrbitalTransforms(int sopsl, msym_symmetry_operation_t sops[], int l, double ***transform){
     msym_error_t ret = MSYM_SUCCESS;
     int kdim = ipow(3,l), norbs = 2*l+1;
-    double (*mkron)[kdim][kdim] = malloc(sizeof(double[2][kdim][kdim]));
-    double (*poly)[kdim] = malloc(sizeof(double[norbs][kdim]));
+    double (***mkron) = malloc(sizeof(double)*2*kdim*kdim);
+    double (**poly) = malloc(sizeof(double)*norbs*kdim);
     
     for(int m = -l; m <= l;m++){
         if(MSYM_SUCCESS != (ret = orbitalPolynomial(l,m,poly[m+l]))) goto err;
@@ -187,7 +193,7 @@ err:
     return ret;
 }
 
-msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, int basisl, msym_orbital_t basis[basisl], msym_thresholds_t *thresholds, int *subspacel, msym_subspace_t **subspace, int **pspan){
+msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, int basisl, msym_orbital_t basis[], msym_thresholds_t *thresholds, int *subspacel, msym_subspace_t **subspace, int **pspan){
     msym_error_t ret = MSYM_SUCCESS;
     int lmax = -1, nmax = -1, eslmax = -1;
     for(int i = 0;i < basisl;i++){
@@ -200,16 +206,16 @@ msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equi
     for(int i = 0;i < esl;i++) eslmax = es[i].length > eslmax ? es[i].length : eslmax;
     
     struct _ltransforms {int d; void *t;} *lts = calloc(lmax+1,sizeof(struct _ltransforms));
-    double (*mkron)[(2*lmax+1)*pg->order] = malloc(sizeof(double[(2*lmax+1)*pg->order][(2*lmax+1)*pg->order]));
-    double (*mperm)[pg->order] = malloc(sizeof(double[pg->order][pg->order]));
+    double (**mkron) = malloc(sizeof(double)*((2 * lmax + 1)*pg->order)*((2 * lmax + 1)*pg->order));
+    double (**mperm) = malloc(sizeof(double)*pg->order*pg->order);
     
-    double (*mproj)[pg->ct->l+1][(2*lmax+1)*pg->order][(2*lmax+1)*pg->order] = malloc(sizeof(double[lmax+1][pg->ct->l+1][(2*lmax+1)*pg->order][(2*lmax+1)*pg->order]));
-    double (*lspan)[pg->ct->l] = malloc(sizeof(double[lmax+1][pg->ct->l]));
+    double (****mproj) = malloc(sizeof(double)*((2 * lmax + 1)*pg->order)*((2 * lmax + 1)*pg->order)*(pg->ct->l+1)*(lmax+1));
+    double (**lspan) = malloc(sizeof(double)*(lmax+1)*(pg->ct->l));
     int (*ispan) = calloc(pg->ct->l,sizeof(int));
     int *aspan = calloc(pg->ct->l,sizeof(int));
-    int *nl = malloc(sizeof(int[lmax+1]));
+    int *nl = malloc(sizeof(int)*(lmax+1));
     
-    msym_orbital_t *(*omap)[nmax][lmax][2*lmax+1] = malloc(sizeof(msym_orbital_t *[eslmax][nmax+1][lmax+1][2*lmax+1]));
+    msym_orbital_t ****(*omap)= malloc(sizeof(msym_orbital_t *)*(eslmax)*(nmax+1)*(lmax+1)*(2*lmax+1));
     
     *subspace = NULL;
     
@@ -223,23 +229,23 @@ msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equi
     
     for(int l = 0; l <= lmax;l++){
         lts[l].d = 2*l+1;
-        lts[l].t = malloc(sizeof(double[pg->sopsl][lts[l].d][lts[l].d]));
+        lts[l].t = malloc(sizeof(double)*(lts[1].d)*(lts[1].d)*(pg->sopsl));
         if(MSYM_SUCCESS != (ret = generateOrbitalTransforms(pg->sopsl, pg->sops, l, lts[l].t))) goto err;
     }
     
     for(int i = 0; i < esl;i++){
         int esilmax = -1, esinmax = -1;
         
-        memset(nl,0,sizeof(int[lmax+1]));
+        memset(nl,0,sizeof(int)*(lmax+1));
         for(int j = 0;j < es[i].elements[0]->aol;j++){
             esilmax = esilmax < es[i].elements[0]->ao[j]->l ? es[i].elements[0]->ao[j]->l : esilmax;
             esinmax = esinmax < es[i].elements[0]->ao[j]->n ? es[i].elements[0]->ao[j]->n : esinmax;
             nl[es[i].elements[0]->ao[j]->l] += es[i].elements[0]->ao[j]->m == 0;
         }
         
-        msym_orbital_t *(*esomap)[esinmax+1][esilmax+1][2*esilmax+1] = omap;
+        msym_orbital_t ****(*esomap)= omap;
         
-        memset(esomap,0,sizeof(msym_orbital_t *[es->length][esinmax+1][esilmax+1][2*esilmax+1]));
+        memset(esomap,0,sizeof(msym_orbital_t *)*(es->length)*(esinmax+1)*(esilmax+1)*(2*esilmax+1));
         for(int a = 0;a < es[i].length;a++){
             for(int ao = 0;ao < es[i].elements[a]->aol;ao++){
                 msym_orbital_t *o = es[i].elements[a]->ao[ao];
@@ -247,16 +253,16 @@ msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equi
             }
         }
         
-        memset(lspan,0,sizeof(double[lmax+1][pg->ct->l]));
+        memset(lspan,0,sizeof(double)*(lmax+1)*(pg->ct->l));
         
         for(int l = 0;l <= esilmax;l++){
             int d = es[i].length*lts[l].d;
-            double (*mlproj)[d][d] = mproj[l];
-            memset(mlproj,0,sizeof(double[pg->ct->l][d][d]));
-            memset(ispan,0,sizeof(int[pg->ct->l]));
+            double (***mlproj) = mproj[l];
+            memset(mlproj,0,sizeof(double)*d*d*pg->ct->l);
+            memset(ispan,0,sizeof(int)*pg->ct->l);
             
             for(int s = 0;s < pg->sopsl;s++){
-                double (*lt)[lts[l].d][lts[l].d] = lts[l].t;
+                double (***lt) = lts[l].t;
                 permutationMatrix(&perm[i][s], mperm);
                 kron(perm[i][s].p_length,mperm,lts[l].d,lt[s],d,mkron);
                 
@@ -269,7 +275,7 @@ msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equi
                     mladd(d, mlproj[pg->ct->l], mlproj[k], mlproj[k]); //Could do this based on the span later, but it's not a huge amount of work
                 }
             }
-            memset(mlproj[pg->ct->l],0,sizeof(double[d][d]));
+            memset(mlproj[pg->ct->l],0,sizeof(double)*d*d);
             int nirrepl = 0;
             for(int k = 0;k < pg->ct->l;k++){
                 int lirrepl = nirrepl;
@@ -290,7 +296,7 @@ msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equi
                 ss->irrep = k;
                 
                 if(ispan[k] > 0){
-                    ss->subspace = realloc(ss->subspace, sizeof(msym_subspace_t[ss->subspacel+nl[l]]));
+                    ss->subspace = realloc(ss->subspace, sizeof(msym_subspace_t)*(ss->subspacel+nl[l]));
                     for(int n = l+1; n <= esinmax;n++){
                         if(esomap[0][n][l][0] == NULL) continue;
                         
@@ -301,13 +307,13 @@ msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equi
                         nss->type = ATOMIC_ORBITAL;
                         nss->irrep = ss->irrep;
                         nss->d = ispan[k]*pg->ct->irrep[k].d;
-                        double (*space)[d] = malloc(sizeof(double[nss->d][d]));
+                        double (**space) = malloc(sizeof(double)*d*nss->d);
                         for(int dim = 0; dim < ss->subspace[ss->subspacel].d;dim++){
                             vlnorm2(d, mlproj[pg->ct->l][lirrepl+dim], space[dim]);
                         }
                         nss->space = (double*) space;
                         nss->basisl = 0;
-                        nss->basis.o = malloc(sizeof(msym_orbital_t *[d]));
+                        nss->basis.o = malloc(sizeof(msym_orbital_t *)*d);
                         for(int e = 0;e < es[i].length;e++){
                             for(int m = -l;m <= l;m++){
                                 nss->basis.o[nss->basisl++] = esomap[e][n][l][m+l];
@@ -371,10 +377,10 @@ err:
     return ret;
 }
 
-msym_error_t getOrbitalSubspaces(int ssl, msym_subspace_t ss[ssl], int basisl, msym_orbital_t basis[basisl], double c[basisl][basisl]){
+msym_error_t getOrbitalSubspaces(int ssl, msym_subspace_t ss[], int basisl, msym_orbital_t basis[], double **c){
     msym_error_t ret = MSYM_SUCCESS;
     int index = 0;
-    memset(c,0,sizeof(double[basisl][basisl]));
+    memset(c,0,sizeof(c));
     for(int i = 0;i < ssl;i++){
         if(MSYM_SUCCESS != (ret = getOrbitalSubspaceCoefficients(&ss[i],basisl,basis,&index,c))) goto err;
     }
@@ -390,7 +396,7 @@ err:
     return ret;
 }
 
-msym_error_t getOrbitalSubspaceCoefficients(msym_subspace_t *ss, int basisl, msym_orbital_t basis[basisl], int *offset, double c[basisl][basisl]){
+msym_error_t getOrbitalSubspaceCoefficients(msym_subspace_t *ss, int basisl, msym_orbital_t basis[], int *offset, double **c){
     msym_error_t ret = MSYM_SUCCESS;
     
     int index = *offset;
@@ -401,7 +407,7 @@ msym_error_t getOrbitalSubspaceCoefficients(msym_subspace_t *ss, int basisl, msy
     }
     
     if(ss->subspacel == 0){
-        double (*space)[ss->basisl] = (double (*)[ss->basisl]) ss->space;
+        double (**space) =  ss->space;
         if(index+ss->d > basisl) {
             msymSetErrorDetails("Generated subspaces (%d) is larger than basis length (%d)",index+ss->d,basisl);
             ret = MSYM_INVALID_SUBSPACE;
@@ -443,7 +449,7 @@ int filterSubspace(msym_subspace_t *ss){
                     break;
                 } else {
                     memcpy(&ss->subspace[i], &ss->subspace[ss->subspacel], sizeof(msym_subspace_t));
-                    ss->subspace = realloc(ss->subspace, sizeof(msym_subspace_t[ss->subspacel]));
+                    ss->subspace = realloc(ss->subspace, sizeof(msym_subspace_t)*ss->subspacel);
                     i--;
                 }
                 
@@ -481,7 +487,7 @@ void printSubspaceTree(CharacterTable *ct, msym_subspace_t *ss,int indent){
             tabprintf("", indent);
             for(int i = 0;i < ss->basisl;i++) printf("  %s\t",ss->basis.o[i]->name);
             printf("\n");
-            double (*space)[ss->basisl] = (double (*)[ss->basisl]) ss->space;
+            double (**space) =  ss->space;
             tabPrintTransform(ss->d,ss->basisl,space,indent);
         } else {
             tabprintf("No subspaces spaned\n", indent);
@@ -503,8 +509,8 @@ void tabprintf(char *format, int indent, ...){
 
 
 //Density matrix without occupation numbers
-void densityMatrix(int l, double M[l][l], double D[l][l]){
-    memset(D,0,sizeof(double[l][l]));
+void densityMatrix(int l, double **M, double **D){
+    memset(D,0,sizeof(D));
     for(int i = 0; i < l;i++){
         for(int j = 0;j < l;j++){
             for(int k = 0;k < l;k++){
@@ -518,7 +524,7 @@ void printOrbital(msym_orbital_t *orb){
     printf("Orbital(%d,%d,%d) : %s\n",orb->n, orb->l, orb->m, orb->name);
 }
 
-void printTransform(int r, int c, double M[r][c]) {
+void printTransform(int r, int c, double **M) {
     
     printf("\n[");
     for(int i = 0;i < r;i++){
@@ -534,7 +540,7 @@ void printTransform(int r, int c, double M[r][c]) {
     
 }
 
-void tabPrintTransform(int r, int c, double M[r][c],int indent) {
+void tabPrintTransform(int r, int c, double **M,int indent) {
     if(r == 0 || c == 0) {tabprintf("[]\n",indent);return;}
     //printf("\n");
     tabprintf("[",indent);
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/orbital.h b/libavogadro/src/extensions/symmetry/libmsym/src/orbital.h
index 4306fef..e86f062 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/orbital.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/orbital.h
@@ -52,10 +52,10 @@ typedef struct {
 msym_error_t orbitalFromName(char *, msym_orbital_t *orb);
 msym_error_t orbitalFromQuantumNumbers(int n, int l, int m, msym_orbital_t *orb);
 void printOrbital(msym_orbital_t *orb);
-msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, int basisl, msym_orbital_t basis[basisl], msym_thresholds_t *thresholds, int *subspacel, msym_subspace_t **subspace, int **pspan);
-msym_error_t generateOrbitalTransforms(int sopsl, msym_symmetry_operation_t sops[sopsl], int l, double transform[sopsl][2*l+1][2*l+1]);
+msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, int basisl, msym_orbital_t *basis, msym_thresholds_t *thresholds, int *subspacel, msym_subspace_t **subspace, int **pspan);
+msym_error_t generateOrbitalTransforms(int sopsl, msym_symmetry_operation_t *sops, int l, double ***transform);
 void freeSubspace(msym_subspace_t *ss);
-msym_error_t getOrbitalSubspaces(int ssl, msym_subspace_t ss[ssl],int basisl, msym_orbital_t basis[basisl], double c[basisl][basisl]);
+msym_error_t getOrbitalSubspaces(int ssl, msym_subspace_t *ss,int basisl, msym_orbital_t *basis, double **c);
 
 void printSubspace(CharacterTable *ct, msym_subspace_t *ss);
 
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/permutation.c b/libavogadro/src/extensions/symmetry/libmsym/src/permutation.c
index 3dd89df..86905b1 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/permutation.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/permutation.c
@@ -25,13 +25,13 @@ void freePermutationData(msym_permutation_t *perm){
     }
 }
 
-msym_error_t findPermutation(msym_symmetry_operation_t *sop, int l, double (*v[l])[3], msym_thresholds_t *t, msym_permutation_t *perm){
+msym_error_t findPermutation(msym_symmetry_operation_t *sop, int l, double (*v[])[3], msym_thresholds_t *t, msym_permutation_t *perm){
     msym_error_t ret = MSYM_SUCCESS;
     double m[3][3];
     symmetryOperationMatrix(sop, m);
     
-    perm->p = malloc(sizeof(int[l]));
-    memset(perm->p, -1, sizeof(int[l]));
+    perm->p = malloc(sizeof(int)*l);
+    memset(perm->p, -1, sizeof(int)*l);
     perm->p_length = l;
     
     for(int i = 0; i < l;i++){
@@ -70,18 +70,18 @@ typedef struct _perm_subgroup {
 
 
 
-msym_error_t findPermutationSubgroups(int l, msym_permutation_t perm[l], int sgmax, msym_symmetry_operation_t *sops, int *subgroupl, msym_subgroup_t **subgroup){
+msym_error_t findPermutationSubgroups(int l, msym_permutation_t perm[], int sgmax, msym_symmetry_operation_t *sops, int *subgroupl, msym_subgroup_t **subgroup){
     msym_error_t ret = MSYM_SUCCESS;
     perm_subgroup_t *group = calloc(l, sizeof(perm_subgroup_t));
     
-    int *isops = malloc(sizeof(int[l]));
-    int *msops = malloc(sizeof(int[l]));
+    int *isops = malloc(sizeof(int)*l);
+    int *msops = malloc(sizeof(int)*l);
     int gl = 0;
     
     for(int i = 0;i < l;i++){
         if((sops[i].power == 1 && (sops[i].type == PROPER_ROTATION || sops[i].type == IMPROPER_ROTATION)) || sops[i].type == INVERSION || sops[i].type == REFLECTION){
             msym_permutation_cycle_t* c = perm[i].c;
-            memset(msops, 0, sizeof(int[l]));
+            memset(msops, 0, sizeof(int)*l);
             group[gl].sopsl = c->l;
             group[gl].sops = calloc(c->l, sizeof(int));
             group[gl].subgroup[0] = group[gl].subgroup[1] = -1;
@@ -105,11 +105,11 @@ msym_error_t findPermutationSubgroups(int l, msym_permutation_t perm[l], int sgm
     for(int i = 0;i < gl && gl < sgmax;i++){
         for(int j = i+1;j < gl && gl < sgmax;j++){
             int minl = group[i].sopsl < group[j].sopsl ? group[i].sopsl : group[j].sopsl;
-            if(0 == memcmp(group[i].sops,group[j].sops,sizeof(int[minl]))) continue;
+            if(0 == memcmp(group[i].sops,group[j].sops,sizeof(int)*minl)) continue;
             
             int n = 0;
-            memset(isops, 0, sizeof(int[l]));
-            memset(msops, 0, sizeof(int[l]));
+            memset(isops, 0, sizeof(int)*l);
+            memset(msops, 0, sizeof(int)*l);
             
             for(int k = 0;k < group[i].sopsl;k++){
                 int s = group[i].sops[k];
@@ -138,7 +138,7 @@ msym_error_t findPermutationSubgroups(int l, msym_permutation_t perm[l], int sgm
             
             if(n < l && n > 1) {
                 n = 0;
-                memset(isops, 0, sizeof(int[l]));
+                memset(isops, 0, sizeof(int)*l);
 
                 for(int k = 0;k < l;k++){
                     if(msops[k]){
@@ -148,15 +148,15 @@ msym_error_t findPermutationSubgroups(int l, msym_permutation_t perm[l], int sgm
                 }
                 int f;
                 for(f = 0;f < gl;f++){
-                    if(group[f].sopsl == n && 0 == memcmp(group[f].sops, isops, sizeof(int[n]))){
+                    if(group[f].sopsl == n && 0 == memcmp(group[f].sops, isops, sizeof(int)*n)){
                         break;
                     }
                 }
                 if(f == gl){
-                    group = realloc(group, sizeof(perm_subgroup_t[gl+1]));
+                    group = realloc(group, sizeof(perm_subgroup_t)*(gl+1));
                     group[gl].sopsl = n;
-                    group[gl].sops = malloc(sizeof(int[n]));
-                    memcpy(group[gl].sops, isops, sizeof(int[n]));
+                    group[gl].sops = malloc(sizeof(int)*n);
+                    memcpy(group[gl].sops, isops, sizeof(int)*n);
                     group[gl].subgroup[0] = i;
                     group[gl].subgroup[1] = j;
                     gl++;
@@ -190,19 +190,19 @@ err:
     return ret;
 }
 
-msym_error_t findSymmetryOperationPermutations(int l, msym_symmetry_operation_t sops[l], msym_thresholds_t *t, msym_permutation_t **rperm){
+msym_error_t findSymmetryOperationPermutations(int l, msym_symmetry_operation_t sops[], msym_thresholds_t *t, msym_permutation_t **rperm){
     
     msym_error_t ret = MSYM_SUCCESS;
     //Don't block allocate this, it's a pain to keep track of the pointers
-    msym_permutation_t *permutations = malloc(sizeof(msym_permutation_t[l]));
+    msym_permutation_t *permutations = malloc(sizeof(msym_permutation_t)*l);
     
     for(int i = 0; i < l;i++){
-        permutations[i].p = malloc(sizeof(int[l]));
-        memset(permutations[i].p, -1, sizeof(int[l]));
+        permutations[i].p = malloc(sizeof(int)*l);
+        memset(permutations[i].p, -1, sizeof(int)*l);
         permutations[i].p_length = l;
     }
     
-    double (*msops)[3][3] = malloc(sizeof(double[l][3][3]));
+    double (*msops)[3][3] = malloc(sizeof(double[3][3])*l);
     
     for(int i = 0; i < l;i++){
         symmetryOperationMatrix(&sops[i], msops[i]);
@@ -257,13 +257,13 @@ err:
 msym_error_t setPermutationCycles(msym_permutation_t *perm){
     msym_error_t ret = MSYM_SUCCESS;
     int l = perm->p_length;
-    int *icycle = malloc(sizeof(int[l]));
-    int *pcycle = malloc(sizeof(int[l]));
-    int *lcycle = malloc(sizeof(int[l]));
+    int *icycle = malloc(sizeof(int)*l);
+    int *pcycle = malloc(sizeof(int)*l);
+    int *lcycle = malloc(sizeof(int)*l);
     
     int cl = 0;
-    memset(icycle, -1,sizeof(int[l]));
-    memset(lcycle,  0,sizeof(int[l]));
+    memset(icycle, -1,sizeof(int)*l);
+    memset(lcycle,  0,sizeof(int)*l);
     
     perm->c = NULL;
     perm->c_length = 0;
@@ -285,7 +285,7 @@ msym_error_t setPermutationCycles(msym_permutation_t *perm){
         cl++;
     }
     perm->c_length = cl;
-    perm->c = malloc(sizeof(msym_permutation_cycle_t[cl]));
+    perm->c = malloc(sizeof(msym_permutation_cycle_t)*cl);
     for(int c = 0; c < cl;c++){
         perm->c[c].l = lcycle[c];
         perm->c[c].s = pcycle[c];
@@ -300,9 +300,10 @@ err:
 
 
 //We need these as doubles later, so might as well, even though we could represent these with ALOT less memory
-void permutationMatrix(msym_permutation_t *perm, double m[perm->p_length][perm->p_length]){
-    memset(m, 0, sizeof(double[perm->p_length][perm->p_length]));
-    for(int i = 0;i < perm->p_length;i++){
+void permutationMatrix(msym_permutation_t *perm, double **m){
+    //memset(m, 0, sizeof(double[perm->p_length][perm->p_length]));
+	memset(m, 0, sizeof(m));
+	for(int i = 0;i < perm->p_length;i++){
         //m[i][perm->p[i]] = 1.0;
         m[perm->p[i]][i] = 1.0;
     }
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/permutation.h b/libavogadro/src/extensions/symmetry/libmsym/src/permutation.h
index 5e2c4ed..35f62f7 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/permutation.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/permutation.h
@@ -42,11 +42,11 @@ typedef struct _msym_permutation_morphism {
 } msym_permutation_morphism_t;
 
 
-msym_error_t findSymmetryOperationPermutations(int l, msym_symmetry_operation_t sops[l], msym_thresholds_t *t, msym_permutation_t **ret);
-msym_error_t findPermutation(msym_symmetry_operation_t *sop, int l, double (*v[l])[3], msym_thresholds_t *t, msym_permutation_t *perm);
+msym_error_t findSymmetryOperationPermutations(int l, msym_symmetry_operation_t *sops, msym_thresholds_t *t, msym_permutation_t **ret);
+msym_error_t findPermutation(msym_symmetry_operation_t *sop, int l, double (**v)[3], msym_thresholds_t *t, msym_permutation_t *perm);
 void freePermutationData(msym_permutation_t *perm);
-void permutationMatrix(msym_permutation_t *perm, double m[perm->p_length][perm->p_length]);
-msym_error_t findPermutationSubgroups(int l, msym_permutation_t perm[l], int sgmax, msym_symmetry_operation_t *sops, int *subgroupl, msym_subgroup_t **subgroup);
+void permutationMatrix(msym_permutation_t *perm, double **m);
+msym_error_t findPermutationSubgroups(int l, msym_permutation_t *perm, int sgmax, msym_symmetry_operation_t *sops, int *subgroupl, msym_subgroup_t **subgroup);
 
 void printPermutation(msym_permutation_t *perm);
 
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/point_group.c b/libavogadro/src/extensions/symmetry/libmsym/src/point_group.c
index ffcf128..e427426 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/point_group.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/point_group.c
@@ -689,7 +689,7 @@ msym_error_t pointGroupFromSubgroup(msym_subgroup_t *sg, msym_thresholds_t *thre
     pg->type = sg->type;
     pg->primary = sg->primary;
     pg->n = sg->n;
-    pg->sops = malloc(sizeof(msym_symmetry_operation_t[sg->sopsl]));
+    pg->sops = malloc(sizeof(msym_symmetry_operation_t)*sg->sopsl);
     pg->sopsl = sg->sopsl;
     memcpy(pg->name,sg->name,sizeof(pg->name));
     
@@ -998,7 +998,7 @@ msym_error_t generateSymmetryOperations(msym_point_group_t *pg, msym_thresholds_
     msym_error_t ret = MSYM_SUCCESS;
     double origo[3] = {0.0,0.0,0.0};
 
-    pg->sops = malloc(sizeof(msym_symmetry_operation_t[pg->order+1]));
+    pg->sops = malloc(sizeof(msym_symmetry_operation_t)*(pg->order+1));
     vcopy(origo,pg->sops[0].v);
     
     pg->sops[0].type = IDENTITY;
@@ -1076,7 +1076,7 @@ msym_error_t generateSymmetryOperations(msym_point_group_t *pg, msym_thresholds_
         goto err;
     }
     
-    pg->sops = realloc(pg->sops,sizeof(msym_symmetry_operation_t[pg->order]));
+    pg->sops = realloc(pg->sops,sizeof(msym_symmetry_operation_t)*pg->order);
     
     return ret;
     
@@ -1529,8 +1529,8 @@ void generateSymmetryOperationsIh(msym_point_group_t *pg){
 
 int classifySymmetryOperations(msym_point_group_t *pg){
     int c = 1;
-    double (*mop)[3][3] = malloc(sizeof(double[pg->sopsl][3][3]));
-    double (*imop)[3][3] = malloc(sizeof(double[pg->sopsl][3][3]));
+    double (*mop)[3][3] = malloc(sizeof(double[3][3])*pg->sopsl);
+    double (*imop)[3][3] = malloc(sizeof(double[3][3])*pg->sopsl);
     
     //There may be a better way to do this
     for(int i = 0; i < pg->sopsl;i++){
@@ -1695,12 +1695,12 @@ msym_error_t findCharacterTable(msym_point_group_t *pg){
         goto err;
     }
     
-    ct = realloc(ct, sizeof(CharacterTable)+sizeof(int[ct->l])+ct->l*sizeof(*ct->name));
+    ct = realloc(ct, sizeof(CharacterTable)+(sizeof(int)*ct->l)+ct->l*sizeof(*ct->name));
 
     ct->classc = (int*)(ct + 1);
     ct->name = (char (*)[6]) ((int *)ct->classc + ct->l);
         
-    memset(ct->classc, 0, sizeof(int[ct->l]));
+    memset(ct->classc, 0, sizeof(int)*ct->l);
     memset(ct->name, 0, ct->l*sizeof(*(ct->name)));
     for(int i = 0; i < pg->sopsl;i++){
         ct->classc[pg->sops[i].cla]++;
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.c b/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.c
index 99aa24c..d3082d5 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.c
@@ -19,7 +19,7 @@
 
 #define SQR(x) ((x)*(x))
 
-msym_error_t projectOntoSubspace(int d, double orb[d], msym_subspace_t *ss, msym_orbital_t basis[d], double mem[d], double proj[d]);
+msym_error_t projectOntoSubspace(int d, double orb[], msym_subspace_t *ss, msym_orbital_t basis[], double mem[], double proj[]);
 
 msym_error_t symmetrizeMoleculeProject(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, msym_thresholds_t *thresholds, double *err);
 msym_error_t symmetrizeMoleculeLinear(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, msym_thresholds_t *thresholds, double *err);
@@ -44,14 +44,14 @@ msym_error_t symmetrizeMolecule(msym_point_group_t *pg, int esl, msym_equivalenc
 msym_error_t symmetrizeMoleculeProject(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, msym_thresholds_t *thresholds, double *err){
     msym_error_t ret = MSYM_SUCCESS;
     double e = 0.0;
-    double (*v)[3] = malloc(sizeof(double[pg->order][3]));
+    double (*v)[3] = malloc(sizeof(double[3])*pg->order);
     for(int i = 0; i < esl;i++){
         if(es[i].length > pg->order){
             ret = MSYM_SYMMETRIZATION_ERROR;
             msymSetErrorDetails("Equivalence set (%d elements) larger than order of point group (%d)",es[i].length,pg->order);
             goto err;
         }
-        memset(v, 0, sizeof(double[pg->order][3]));
+        memset(v, 0, sizeof(double[3])*pg->order);
         for(int j = 0; j < pg->sopsl;j++){
             for(int k = 0; k < es[i].length;k++){
                 int p = perm[i][j].p[k];
@@ -79,8 +79,8 @@ err:
 msym_error_t symmetrizeMoleculeLinear(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, msym_thresholds_t *thresholds, double *err){
     msym_error_t ret = MSYM_SUCCESS;
     double e = 0.0;
-    double (*v)[3] = malloc(sizeof(double[pg->order][3]));
-    double (*vinf)[3] = malloc(sizeof(double[pg->order][3]));
+    double (*v)[3] = malloc(sizeof(double[3])*pg->order);
+    double (*vinf)[3] =  malloc(sizeof(double[3])*pg->order);
     msym_symmetry_operation_t *cinf = NULL;
     
     for(int i = 0; i < pg->sopsl;i++){
@@ -103,7 +103,7 @@ msym_error_t symmetrizeMoleculeLinear(msym_point_group_t *pg, int esl, msym_equi
             goto err;
         }
         
-        memset(v, 0, sizeof(double[pg->order][3]));
+        memset(v, 0, sizeof(double[3])*pg->order);
         
         for(int k = 0; k < es[i].length;k++){
             vproj(es[i].elements[k]->v, cinf->v, vinf[k]);
@@ -137,14 +137,14 @@ err:
 }
 
 
-msym_error_t symmetrizeOrbitals(msym_point_group_t *pg, int ssl, msym_subspace_t *ss, int *span, int basisl, msym_orbital_t basis[basisl], msym_thresholds_t *thresholds, double orb[basisl][basisl],double symorb[basisl][basisl]){
+msym_error_t symmetrizeOrbitals(msym_point_group_t *pg, int ssl, msym_subspace_t *ss, int *span, int basisl, msym_orbital_t basis[], msym_thresholds_t *thresholds, double **orb,double **symorb){
     msym_error_t ret = MSYM_SUCCESS;
-    double (*proj)[pg->ct->l][basisl] = malloc(sizeof(double[basisl][pg->ct->l][basisl]));
-    double *mem = malloc(sizeof(double[basisl]));
-    double (*comp)[pg->ct->l] = malloc(sizeof(double[basisl][pg->ct->l]));
+    double (***proj) = malloc(sizeof(double)*basisl*basisl*pg->ct->l);
+    double *mem = malloc(sizeof(double)*basisl);
+    double (**comp) = malloc(sizeof(double)*basisl*pg->ct->l);
     int *icomp = calloc(basisl,sizeof(int));
     int (*ispan) = calloc(pg->ct->l,sizeof(int));
-    memset(proj,0,sizeof(double[basisl][pg->ct->l][basisl]));
+    memset(proj,0,sizeof(double)*basisl*basisl*pg->ct->l);
     
     for(int o = 0;o < basisl;o++){
         double mcomp = -1.0;
@@ -224,7 +224,7 @@ err:
     return ret;
 }
 
-msym_error_t projectOntoSubspace(int d, double orb[d], msym_subspace_t *ss, msym_orbital_t basis[d], double mem[d], double proj[d]){
+msym_error_t projectOntoSubspace(int d, double orb[], msym_subspace_t *ss, msym_orbital_t basis[], double mem[], double proj[]){
     msym_error_t ret = MSYM_SUCCESS;
     if(ss->subspacel){
         for(int i = 0;i < ss->subspacel;i++){
@@ -232,8 +232,8 @@ msym_error_t projectOntoSubspace(int d, double orb[d], msym_subspace_t *ss, msym
         }
     } else {
         for(int i = 0; i < ss->d;i++){
-            double (*space)[ss->basisl] = (double (*)[ss->basisl]) ss->space;
-            memset(mem, 0, sizeof(double[d]));
+            double (**space) =  ss->space;
+            memset(mem, 0, sizeof(double)*d);
             for(int j = 0; j < ss->basisl;j++){
                 mem[ss->basis.o[j] - basis] = space[i][j];
             }
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.h b/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.h
index 364261b..6fd0955 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.h
@@ -18,7 +18,7 @@
 #include "permutation.h"
 
 msym_error_t symmetrizeMolecule(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, msym_thresholds_t *thresholds, double *err);
-msym_error_t symmetrizeOrbitals(msym_point_group_t *pg, int ssl, msym_subspace_t *ss, int *span, int basisl, msym_orbital_t basis[basisl], msym_thresholds_t *thresholds, double orb[basisl][basisl],double symorb[basisl][basisl]);
+msym_error_t symmetrizeOrbitals(msym_point_group_t *pg, int ssl, msym_subspace_t *ss, int *span, int basisl, msym_orbital_t *basis, msym_thresholds_t *thresholds, double **orb,double **symorb);
 msym_error_t symmetrizeTranslation(msym_point_group_t *pg, msym_equivalence_set_t *es, msym_permutation_t *perm, int pi, double translation[3]);
 
 
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.c b/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.c
index 11d7470..6e070a3 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.c
@@ -39,10 +39,10 @@ msym_error_t findSymmetryAsymmetricPolyhedron(msym_equivalence_set_t *es, double
 msym_error_t findSymmetrySpherical(msym_equivalence_set_t *es, double cm[3], double ev[3][3], msym_thresholds_t *thresholds, int *rsopsl, msym_symmetry_operation_t **rsops);
 msym_error_t findSymmetryCubic(msym_equivalence_set_t *es, double cm[3], double ev[3][3], msym_thresholds_t *thresholds, int *rsopsl, msym_symmetry_operation_t **rsops);
 msym_error_t findSymmetryUnknown(msym_equivalence_set_t *es, double cm[3], double ev[3][3], msym_thresholds_t *t, int *rsopsl, msym_symmetry_operation_t **rsops);
-msym_error_t reduceSymmetry(int sopsl, msym_symmetry_operation_t sops[sopsl], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops);
-msym_error_t filterSymmetryOperations(int sopsl, msym_symmetry_operation_t sops[sopsl], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops);
+msym_error_t reduceSymmetry(int sopsl, msym_symmetry_operation_t sops[], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops);
+msym_error_t filterSymmetryOperations(int sopsl, msym_symmetry_operation_t sops[], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops);
 
-msym_error_t findSymmetryOperations(int esl, msym_equivalence_set_t es[esl], msym_thresholds_t *t, int *lsops, msym_symmetry_operation_t **sops){
+msym_error_t findSymmetryOperations(int esl, msym_equivalence_set_t es[], msym_thresholds_t *t, int *lsops, msym_symmetry_operation_t **sops){
     msym_error_t ret = MSYM_SUCCESS;
     msym_symmetry_operation_t *rsops = NULL;
     int lrsops = 0;
@@ -654,7 +654,7 @@ msym_error_t findSymmetryCubic(msym_equivalence_set_t *es, double cm[3], double
     msym_symmetry_operation_t *sops = malloc(sizeof(msym_symmetry_operation_t[120]));
     int sopsl = 0;
     
-    double (**esv)[3] = malloc(sizeof(double (*[es->length])[3]));
+    double (**esv)[3] = malloc(sizeof(double *[3])*es->length);
     
     msym_symmetry_operation_t **sigma = malloc(16*sizeof(msym_symmetry_operation_t*)); //only 15, but we can overflow
     
@@ -1016,7 +1016,7 @@ err:
     return ret;
 }
 
-msym_error_t reduceSymmetry(int sopsl, msym_symmetry_operation_t sops[sopsl], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops){
+msym_error_t reduceSymmetry(int sopsl, msym_symmetry_operation_t sops[], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops){
     msym_error_t ret = MSYM_SUCCESS;
     
     int rsopsl = *isopsl;
@@ -1130,7 +1130,7 @@ msym_error_t reduceSymmetry(int sopsl, msym_symmetry_operation_t sops[sopsl], ms
                 add = vperpendicular(sops[i].v,cinf[0]->v,thresholds->angle);
             }
             if(add){
-                rsops = realloc(rsops, sizeof(msym_symmetry_operation_t[rsopsl+1]));
+                rsops = realloc(rsops, sizeof(msym_symmetry_operation_t)*(rsopsl+1));
                 copySymmetryOperation(&rsops[rsopsl], &sops[i]);
                 rsopsl++;
             }
@@ -1155,7 +1155,7 @@ msym_error_t reduceSymmetry(int sopsl, msym_symmetry_operation_t sops[sopsl], ms
                 if(remove){
                     rsopsl--;
                     copySymmetryOperation(&rsops[i], &rsops[rsopsl]);
-                    rsops = realloc(rsops, sizeof(msym_symmetry_operation_t[rsopsl]));
+                    rsops = realloc(rsops, sizeof(msym_symmetry_operation_t)*rsopsl);
                     i--;
                 } else if(vparallel(rsops[i].v,cinf[1]->v,thresholds->angle)){
                     if(vdot(rsops[i].v,cinf[1]->v) < 0){
@@ -1177,7 +1177,7 @@ err:
     return ret;
 }
 
-msym_error_t filterSymmetryOperations(int sopsl, msym_symmetry_operation_t sops[sopsl], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops){
+msym_error_t filterSymmetryOperations(int sopsl, msym_symmetry_operation_t sops[], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops){
     msym_error_t ret = MSYM_SUCCESS;
     int rsopsl = *isopsl;
     msym_symmetry_operation_t *rsops = *isops;
@@ -1187,7 +1187,7 @@ msym_error_t filterSymmetryOperations(int sopsl, msym_symmetry_operation_t sops[
         if(!fsop){
             rsopsl--;
             copySymmetryOperation(&rsops[i], &rsops[rsopsl]);
-            rsops = realloc(rsops, sizeof(msym_symmetry_operation_t[rsopsl]));
+            rsops = realloc(rsops, sizeof(msym_symmetry_operation_t)*rsopsl);
             i--;
         } else if (rsops[i].type == PROPER_ROTATION || rsops[i].type == IMPROPER_ROTATION || rsops[i].type == REFLECTION){
             if(vdot(rsops[i].v,fsop->v) < 0){
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.h b/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.h
index 8a97c7b..bafd9ad 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.h
@@ -14,6 +14,6 @@
 #include "msym.h"
 #include "symop.h"
 
-msym_error_t findSymmetryOperations(int esl, msym_equivalence_set_t es[esl], msym_thresholds_t *t, int *lsops, msym_symmetry_operation_t **sops);
+msym_error_t findSymmetryOperations(int esl, msym_equivalence_set_t *es, msym_thresholds_t *t, int *lsops, msym_symmetry_operation_t **sops);
 
 #endif /* defined(__MSYM_SYMMETRY_h) */
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/symop.c b/libavogadro/src/extensions/symmetry/libmsym/src/symop.c
index 7f10aaa..ccccfc8 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/symop.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/symop.c
@@ -86,7 +86,7 @@ void symopPow(msym_symmetry_operation_t *A, int pow, msym_symmetry_operation_t *
     }
 }
 
-void symmetryOperationName(msym_symmetry_operation_t* sop, int l, char buf[l]){
+void symmetryOperationName(msym_symmetry_operation_t* sop, int l, char buf[]){
     switch (sop->type) {
         case PROPER_ROTATION   : snprintf(buf, l, "C%d^%d",sop->order,sop->power); break;
         case IMPROPER_ROTATION : snprintf(buf, l, "S%d^%d",sop->order,sop->power); break;
@@ -97,7 +97,7 @@ void symmetryOperationName(msym_symmetry_operation_t* sop, int l, char buf[l]){
     }
 }
 
-void symmetryOperationShortName(msym_symmetry_operation_t* sop, int l, char buf[l]){
+void symmetryOperationShortName(msym_symmetry_operation_t* sop, int l, char buf[]){
     switch (sop->type) {
         case PROPER_ROTATION   : snprintf(buf, l, "C%d",sop->order); break;
         case IMPROPER_ROTATION : snprintf(buf, l, "S%d",sop->order); break;
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/symop.h b/libavogadro/src/extensions/symmetry/libmsym/src/symop.h
index 9b8530e..6bf4d2b 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/symop.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/symop.h
@@ -23,8 +23,8 @@ void symmetryOperationMatrix(msym_symmetry_operation_t *sop, double m[3][3]);
 void copySymmetryOperation(msym_symmetry_operation_t *dst, msym_symmetry_operation_t *src);
 msym_symmetry_operation_t *findSymmetryOperation(msym_symmetry_operation_t*, msym_symmetry_operation_t*, int, msym_thresholds_t *thresholds);
 void invertSymmetryOperation(msym_symmetry_operation_t *sop, msym_symmetry_operation_t *isop);
-void symmetryOperationName(msym_symmetry_operation_t* sop, int l, char buf[l]);
-void symmetryOperationShortName(msym_symmetry_operation_t* sop, int l, char buf[l]);
+void symmetryOperationName(msym_symmetry_operation_t* sop, int l, char *buf);
+void symmetryOperationShortName(msym_symmetry_operation_t* sop, int l, char *buf);
 void printSymmetryOperation(msym_symmetry_operation_t *sop);
 
 #endif /* defined(__MSYM__SYMOP_h) */
diff --git a/scripts/.cmake-msvc2008.bat.swp b/scripts/.cmake-msvc2008.bat.swp
new file mode 100644
index 0000000..800ef8d
Binary files /dev/null and b/scripts/.cmake-msvc2008.bat.swp differ
diff --git a/scripts/cmake-msvc2008.bat b/scripts/cmake-msvc2008.bat
index ba3971a..85b219e 100644
--- a/scripts/cmake-msvc2008.bat
+++ b/scripts/cmake-msvc2008.bat
@@ -1,22 +1,23 @@
 @echo off
 
-SET build_system="NMake Makefiles"
+SET build_system="Visual Studio 14 2015"
 SET build_type="Release"
 
 REM requires NSIS (http://nsis.sourceforge.net)!
 SET cpack_options=-DCPACK_BINARY_NSIS:=ON -DCPACK_BINARY_ZIP:=OFF
 
 REM General
-
-SET PATH=%PATH%;C:\src\qt-4.5.1\bin
-SET openbabel_dir=C:\src\openbabel-2.2.1
-SET openbabel_lib=%openbabel_dir%\output\Release\openbabel-2.lib
-SET eigen2_dir=C:\src\eigen-2.0.1
+SET PATH=%PATH%;D:\src\QT2\bin
+SET openbabel_dir=D:\src\openbabel\include\openbabel-2.0
+SET openbabel_lib=D:\src\openbabel\bin\openbabel-2.lib
+SET eigen3_dir=D:\src\eigen-3
+SET zlib=D:\src\zlib
+SET zliblib=D:\src\zlib\zlib.lib
 
 REM GLSL Support
 
-SET glew_dir=C:\src\glew\include
-SET glew_lib=C:\src\glew\lib\glew32.lib
+SET glew_dir=D:\src\glew\include
+SET glew_lib=D:\src\glew\lib\Release\Win32\glew32.lib
 
 REM Python Support
 
@@ -24,14 +25,14 @@ SET python_dir=C:\src\Python-2.6.2
 SET python_include=%python_dir%\Include
 SET python_lib=%python_dir%\libs\python26.lib
 SET python_exe=%python_dir%\libs\python.exe
-SET boost_dir=C:\src\boost_1_38_0
+SET boost_dir=C:/src/boost_1_38_0
 
 REM Run cmake with GLSL & Python support
-cmake.exe .. -DOPENBABEL2_INCLUDE_DIR=%openbabel_dir%\include -DOPENBABEL2_LIBRARIES=%openbabel_lib% -DEIGEN2_INCLUDE_DIR=%eigen2_dir% -DGLEW_INCLUDE_DIR=%glew_dir% -DGLEW_LIBRARY=%glew_lib% -DENABLE_GLSL:=ON -DPYTHON_INCLUDE_PATH=%python_include% -DPYTHON_LIBRARY=%python_lib% -DPYTHON_EXECUTABLE=%python_exe% -DBOOST_ROOT=%boost_dir% -DCMAKE_BUILD_TYPE=%build_type% -G %build_system% 
+cmake.exe .. -DOPENBABEL2_INCLUDE_DIR=%openbabel_dir% -DOPENBABEL2_LIBRARIES=%openbabel_lib% -DEIGEN3_INCLUDE_DIR=%eigen3_dir% -DGLEW_INCLUDE_DIR=%glew_dir% -DGLEW_LIBRARY=%glew_lib% -DENABLE_GLSL:=ON -DPYTHON_INCLUDE_PATH=%python_include% -DPYTHON_LIBRARY=%python_lib% -DPYTHON_EXECUTABLE=%python_exe% -DZLIB_LIBRARY=%zliblib% -DZLIB_INCLUDE_DIR=%zlib% -DBOOST_ROOT=%boost_dir% -DCMAKE_BUILD_TYPE=%build_type% -G %build_system% 
 
 
 REM Run cmake with GLSL (no python)
-REM cmake.exe .. -DOPENBABEL2_INCLUDE_DIR=%openbabel_dir%\include -DOPENBABEL2_LIBRARIES=%openbabel_lib% -DEIGEN2_INCLUDE_DIR=%eigen2_dir% -DGLEW_INCLUDE_DIR=%glew_dir% -DGLEW_LIBRARY=%glew_lib% -DENABLE_GLSL:=ON -DCMAKE_BUILD_TYPE=%build_type% -G %build_system% 
+REM cmake.exe .. -DOPENBABEL2_INCLUDE_DIR=%openbabel_dir% -DOPENBABEL2_LIBRARIES=%openbabel_lib% -DEIGEN3_INCLUDE_DIR=%eigen3_dir% -DGLEW_INCLUDE_DIR=%glew_dir% -DZLIB_LIBRARY=%zliblib% -DZLIB_INCLUDE_DIR=%zlib% -DGLEW_LIBRARY=%glew_lib% -DENABLE_GLSL:=ON -DCMAKE_BUILD_TYPE=%build_type% -G %build_system% 
 
 REM Run cmake without GLSL & python support
-REM cmake.exe .. -DOPENBABEL2_INCLUDE_DIR=%openbabel_dir%\include -DOPENBABEL2_LIBRARIES=%openbabel_lib% -DEIGEN2_INCLUDE_DIR=%eigen2_dir% -DCMAKE_BUILD_TYPE=%build_type% -G %build_system% 
+REM cmake.exe .. -DOPENBABEL2_INCLUDE_DIR=%openbabel_dir% -DOPENBABEL2_LIBRARIES=%openbabel_lib% -DEIGEN3_INCLUDE_DIR=%eigen3_dir% -DZLIB_LIBRARY=%zliblib% -DZLIB_INCLUDE_DIR=%zlib% -DCMAKE_BUILD_TYPE=%build_type% -G %build_system% 
diff --git a/scripts/cmake-msvc2008.bat~ b/scripts/cmake-msvc2008.bat~
new file mode 100644
index 0000000..904cb80
--- /dev/null
+++ b/scripts/cmake-msvc2008.bat~
@@ -0,0 +1,38 @@
+@echo off
+
+SET build_system="Visual Studio 14 2015"
+SET build_type="Release"
+
+REM requires NSIS (http://nsis.sourceforge.net)!
+SET cpack_options=-DCPACK_BINARY_NSIS:=ON -DCPACK_BINARY_ZIP:=OFF
+
+REM General
+SET PATH=%PATH%;D:\src\QT2
+SET openbabel_dir=D:\src\openbabel\include\openbabel-2.0
+SET openbabel_lib=D:\src\openbabel\bin\openbabel-2.lib
+SET eigen3_dir=D:\src\eigen-3
+SET zlib=D:\src\zlib
+SET zliblib=D:\src\zlib\zlib.lib
+
+REM GLSL Support
+
+SET glew_dir=D:\src\glew\include
+SET glew_lib=D:\src\glew\lib\Release\Win32\glew32.lib
+
+REM Python Support
+
+SET python_dir=C:\src\Python-2.6.2
+SET python_include=%python_dir%\Include
+SET python_lib=%python_dir%\libs\python26.lib
+SET python_exe=%python_dir%\libs\python.exe
+SET boost_dir=C:/src/boost_1_38_0
+
+REM Run cmake with GLSL & Python support
+cmake.exe .. -DOPENBABEL2_INCLUDE_DIR=%openbabel_dir% -DOPENBABEL2_LIBRARIES=%openbabel_lib% -DEIGEN3_INCLUDE_DIR=%eigen3_dir% -DGLEW_INCLUDE_DIR=%glew_dir% -DGLEW_LIBRARY=%glew_lib% -DENABLE_GLSL:=ON -DPYTHON_INCLUDE_PATH=%python_include% -DPYTHON_LIBRARY=%python_lib% -DPYTHON_EXECUTABLE=%python_exe% -DZLIB_LIBRARY=%zliblib% -DZLIB_INCLUDE_DIR=%zlib% -DBOOST_ROOT=%boost_dir% -DCMAKE_BUILD_TYPE=%build_type% -G %build_system% 
+
+
+REM Run cmake with GLSL (no python)
+REM cmake.exe .. -DOPENBABEL2_INCLUDE_DIR=%openbabel_dir% -DOPENBABEL2_LIBRARIES=%openbabel_lib% -DEIGEN3_INCLUDE_DIR=%eigen3_dir% -DGLEW_INCLUDE_DIR=%glew_dir% -DZLIB_LIBRARY=%zliblib% -DZLIB_INCLUDE_DIR=%zlib% -DGLEW_LIBRARY=%glew_lib% -DENABLE_GLSL:=ON -DCMAKE_BUILD_TYPE=%build_type% -G %build_system% 
+
+REM Run cmake without GLSL & python support
+REM cmake.exe .. -DOPENBABEL2_INCLUDE_DIR=%openbabel_dir% -DOPENBABEL2_LIBRARIES=%openbabel_lib% -DEIGEN3_INCLUDE_DIR=%eigen3_dir% -DZLIB_LIBRARY=%zliblib% -DZLIB_INCLUDE_DIR=%zlib% -DCMAKE_BUILD_TYPE=%build_type% -G %build_system% 
