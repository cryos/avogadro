diff --git a/crystals/zeolites/CON.cif b/crystals/zeolites/CON.cif
deleted file mode 100644
index 3a7dfc3..0000000
--- a/crystals/zeolites/CON.cif
+++ /dev/null
@@ -1,69 +0,0 @@
-data_CON
-#**************************************************************************
-#
-# CIF taken from the IZA-SC Database of Zeolite Structures
-# Ch. Baerlocher and L.B. McCusker
-# Database of Zeolite Structures: http://www.iza-structure.org/databases/ 
-#
-# All data on this site have been placed in the public domain.
-# If you use this work in a scientific publication, you are obligated to
-# cite its origin.
-#
-# The atom coordinates and the cell parameters were optimized with DLS76
-# assuming a pure SiO2 composition.
-#
-#**************************************************************************
-
-_cell_length_a                  22.6840(0)
-_cell_length_b                  13.3730(0)
-_cell_length_c                  12.5530(0)
-_cell_angle_alpha               90.0000(0)
-_cell_angle_beta                69.4790(0)
-_cell_angle_gamma               90.0000(0)
-
-_symmetry_space_group_name_H-M     'C 2/m'
-_symmetry_Int_Tables_number         12
-_symmetry_cell_setting             monoclinic
-
-loop_
-_symmetry_equiv_pos_as_xyz
-'+x,+y,+z'
-'1/2+x,1/2+y,+z'
-'-x,+y,-z'
-'1/2-x,1/2+y,-z'
-'-x,-y,-z'
-'1/2-x,1/2-y,-z'
-'+x,-y,+z'
-'1/2+x,1/2-y,+z'
-
-loop_
-_atom_site_label
-_atom_site_type_symbol
-_atom_site_fract_x
-_atom_site_fract_y
-_atom_site_fract_z
-    O1    O     0.0000    0.1506    0.5000
-    O2    O     0.0796    0.0000    0.4485
-    O3    O     0.1196    0.1818    0.3823
-    O4    O     0.0846    0.1341    0.5984
-    O5    O     0.2219    0.1292    0.2129
-    O6    O     0.1805    0.3139    0.2277
-    O7    O     0.1177    0.1690    0.1745
-    O8    O     0.1177    0.1867    0.7715
-    O9    O     0.0002    0.1388    0.8051
-   O10    O     0.0878    0.0000    0.7495
-   O11    O     0.3070    0.0000    0.0941
-   O12    O     0.2695    0.1444    0.9903
-   O13    O     0.3393    0.1863    0.1132
-   O14    O     0.2928    0.0000    0.8390
-   O15    O     0.2016    0.1280    0.8592
-   O16    O     0.0850    0.0000    0.1035
-   O17    O     0.0857    0.1671    0.9928
-    T1    Si    0.0709    0.1165    0.4825
-    T2    Si    0.1598    0.1983    0.2496
-    T3    Si    0.0725    0.1149    0.7310
-    T4    Si    0.2845    0.1148    0.1026
-    T5    Si    0.2708    0.1146    0.8653
-    T6    Si    0.0719    0.1184    0.1166
-    T7    Si    0.1415    0.1990    0.8776
-
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/context.c b/libavogadro/src/extensions/symmetry/libmsym/src/context.c
index 46b48dd..ca06b96 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/context.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/context.c
@@ -118,7 +118,7 @@ err:
 }
 
 
-msym_error_t msymSetElements(msym_context ctx, int length, msym_element_t elements[length]){
+msym_error_t msymSetElements(msym_context ctx, int length, msym_element_t elements[]){
     msym_error_t ret = MSYM_SUCCESS;
     msym_thresholds_t *thresholds = NULL;
     struct {msym_orbital_t *s; msym_orbital_t *e;} aorb = {.s= NULL, .e = NULL} ;
@@ -127,8 +127,8 @@ msym_error_t msymSetElements(msym_context ctx, int length, msym_element_t elemen
     
     if(MSYM_SUCCESS != (ret = msymGetThresholds(ctx, &thresholds))) goto err;
     
-    ctx->elements = malloc(sizeof(msym_element_t[length]));
-    ctx->pelements = malloc(sizeof(msym_element_t *[length]));
+    ctx->elements = malloc(sizeof(msym_element_t)*length);
+    ctx->pelements = malloc(sizeof(msym_element_t *)*length);
     
     for(int i = 0; i < length;i++){
         ctx->pelements[i] = &ctx->elements[i];
@@ -201,16 +201,16 @@ msym_error_t msymGetElements(msym_context ctx, int *length, msym_element_t **ele
     msym_element_t *relements = NULL;
     if(ctx == NULL) {ret = MSYM_INVALID_CONTEXT;goto err;}
     if(ctx->elements == NULL) {ret = MSYM_INVALID_ELEMENTS;goto err;}
-    if(ctx->ext.elements == NULL) ctx->ext.elements = malloc(sizeof(msym_element_t[ctx->el]));
+    if(ctx->ext.elements == NULL) ctx->ext.elements = malloc(sizeof(msym_element_t)*ctx->el);
     if(ctx->orbitals != NULL) {
-        if(ctx->ext.orbitals == NULL) ctx->ext.orbitals = malloc(sizeof(msym_orbital_t[ctx->ol]));
-        memcpy(ctx->ext.orbitals,ctx->orbitals,sizeof(msym_orbital_t[ctx->ol]));
+        if(ctx->ext.orbitals == NULL) ctx->ext.orbitals = malloc(sizeof(msym_orbital_t)*ctx->ol);
+        memcpy(ctx->ext.orbitals,ctx->orbitals,sizeof(msym_orbital_t)*ctx->ol);
     }
     if(ctx->porbitals != NULL){
         if(ctx->ext.porbitals == NULL) ctx->ext.orbitals = calloc(ctx->ol,sizeof(msym_orbital_t*));
     }
     
-    memcpy(ctx->ext.elements,ctx->elements,sizeof(msym_element_t[ctx->el]));
+    memcpy(ctx->ext.elements,ctx->elements,sizeof(msym_element_t)*ctx->el);
     msym_orbital_t **porb = ctx->ext.porbitals;
     for(msym_element_t *a = ctx->ext.elements; a < (ctx->ext.elements+ctx->el); a++){
         vadd(a->v,ctx->cm,a->v);
@@ -259,7 +259,7 @@ err:
 }
 
 
-msym_error_t msymGetPointGroup(msym_context ctx, int l, char buf[l]){
+msym_error_t msymGetPointGroup(msym_context ctx, int l, char buf[]){
     msym_error_t ret = MSYM_SUCCESS;
     if(ctx == NULL) {ret = MSYM_INVALID_CONTEXT;goto err;}
     if(ctx->pg == NULL) {ret = MSYM_INVALID_POINT_GROUP;goto err;}
@@ -290,10 +290,10 @@ msym_error_t msymGetSubgroups(msym_context ctx, int *sgl, msym_subgroup_t **sg){
     }
     
     if(ctx->ext.sg == NULL){
-        ctx->ext.sg = malloc(sizeof(msym_subgroup_t[ctx->sgl]));
-        memcpy(ctx->ext.sg, ctx->sg, sizeof(msym_subgroup_t[ctx->sgl]));
+        ctx->ext.sg = malloc(sizeof(msym_subgroup_t)*ctx->sgl);
+        memcpy(ctx->ext.sg, ctx->sg, sizeof(msym_subgroup_t)*ctx->sgl);
         for(int i = 0;i < ctx->sgl;i++){
-            ctx->ext.sg[i].sops = malloc(sizeof(msym_symmetry_operation_t *[ctx->sg[i].sopsl]));
+            ctx->ext.sg[i].sops = malloc(sizeof(msym_symmetry_operation_t *)*ctx->sg[i].sopsl);
             for(int j = 0;j < ctx->sg[i].sopsl;j++){
                 ctx->ext.sg[i].sops[j] = ctx->sg[i].sops[j] - ctx->pg->sops + ctx->ext.sops;
                 ctx->ext.sg[i].subgroup[0] = ctx->sg[i].subgroup[0] == NULL ? NULL : ctx->sg[i].subgroup[0] - ctx->sg + ctx->ext.sg;
@@ -372,8 +372,8 @@ msym_error_t msymGetSymmetryOperations(msym_context ctx, int *sopsl, msym_symmet
     msym_symmetry_operation_t *rsops = NULL;
     if(ctx == NULL) {ret = MSYM_INVALID_CONTEXT;goto err;}
     if(ctx->pg == NULL || ctx->pg->sops == NULL) {ret = MSYM_INVALID_POINT_GROUP;goto err;}
-    if(ctx->ext.sops == NULL) ctx->ext.sops = malloc(sizeof(msym_symmetry_operation_t[ctx->pg->sopsl]));
-    memcpy(ctx->ext.sops,ctx->pg->sops,sizeof(msym_symmetry_operation_t[ctx->pg->sopsl]));
+    if(ctx->ext.sops == NULL) ctx->ext.sops = malloc(sizeof(msym_symmetry_operation_t)*ctx->pg->sopsl);
+    memcpy(ctx->ext.sops,ctx->pg->sops,sizeof(msym_symmetry_operation_t)*ctx->pg->sopsl);
     *sops = ctx->ext.sops;
     *sopsl = ctx->pg->sopsl;
     return ret;
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.c b/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.c
index 6bd69e5..3f6e12a 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.c
@@ -19,20 +19,20 @@
 
 #define SQR(x) ((x)*(x))
 
-msym_error_t partitionEquivalenceSets(int length, msym_element_t *elements[length], msym_element_t *pelements[length], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
-msym_error_t partitionPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[length], msym_element_t *pelements[length], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
+msym_error_t partitionEquivalenceSets(int length, msym_element_t *elements[], msym_element_t *pelements[], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
+msym_error_t partitionPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[], msym_element_t *pelements[], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
 
 
 
-msym_error_t copyEquivalenceSets(int length, msym_equivalence_set_t es[length], msym_equivalence_set_t **ces){
+msym_error_t copyEquivalenceSets(int length, msym_equivalence_set_t es[], msym_equivalence_set_t **ces){
     msym_error_t ret = MSYM_SUCCESS;
     int el = 0;
     
     for(int i = 0;i < length;i++) el += es[i].length;
-    msym_equivalence_set_t *nes = malloc(sizeof(msym_equivalence_set_t[length]) + sizeof(msym_element_t *[el]));
+    msym_equivalence_set_t *nes = malloc(sizeof(msym_equivalence_set_t)*length + sizeof(msym_element_t *)*el);
     msym_element_t **ep = (msym_element_t **) &es[length];
     msym_element_t **nep = (msym_element_t **) &nes[length];
-    memcpy(nes, es, sizeof(msym_equivalence_set_t[length]) + sizeof(msym_element_t *[el]));
+    memcpy(nes, es, sizeof(msym_equivalence_set_t)*length + sizeof(msym_element_t *)*el);
     for(int i = 0;i < length;i++) nes[i].elements = nes[i].elements - ep + nep;
     *ces = nes;
 err:
@@ -40,9 +40,9 @@ err:
 }
 
 //TODO: Use a preallocated pointer array instead of multiple mallocs
-msym_error_t generateEquivalenceSet(msym_point_group_t *pg, int length, msym_element_t elements[length], int *glength, msym_element_t **gelements, int *esl, msym_equivalence_set_t **es,msym_thresholds_t *thresholds){
+msym_error_t generateEquivalenceSet(msym_point_group_t *pg, int length, msym_element_t elements[], int *glength, msym_element_t **gelements, int *esl, msym_equivalence_set_t **es,msym_thresholds_t *thresholds){
     msym_error_t ret = MSYM_SUCCESS;
-    msym_element_t *ge = calloc(length,sizeof(msym_element_t[pg->order]));
+    msym_element_t *ge = calloc(length,sizeof(msym_element_t)*pg->order);
     msym_equivalence_set_t *ges = calloc(length,sizeof(msym_equivalence_set_t));
     int gel = 0;
     int gesl = 0;
@@ -89,12 +89,12 @@ msym_error_t generateEquivalenceSet(msym_point_group_t *pg, int length, msym_ele
             goto err;
         }
         
-        aes->elements = realloc(aes->elements,sizeof(msym_element_t*[aes->length]));
+        aes->elements = realloc(aes->elements,sizeof(msym_element_t*)*aes->length);
     }
     
     msym_element_t *geo = ge;
-    ge = realloc(ge,sizeof(msym_element_t[gel]));
-    ges = realloc(ges,sizeof(msym_equivalence_set_t[gesl]) + sizeof(msym_element_t *[gel]));
+    ge = realloc(ge,sizeof(msym_element_t)*gel);
+    ges = realloc(ges,sizeof(msym_equivalence_set_t)*gesl + sizeof(msym_element_t *)*gel);
     
     msym_element_t **ep = (msym_element_t **) &ges[gesl];
     for(int i = 0;i < gesl;i++){
@@ -120,7 +120,7 @@ err:
     return ret;
 }
 
-msym_error_t splitPointGroupEquivalenceSets(msym_point_group_t *pg, int esl, msym_equivalence_set_t es[esl], int *sesl, msym_equivalence_set_t **ses, msym_thresholds_t *thresholds){
+msym_error_t splitPointGroupEquivalenceSets(msym_point_group_t *pg, int esl, msym_equivalence_set_t es[], int *sesl, msym_equivalence_set_t **ses, msym_thresholds_t *thresholds){
     msym_error_t ret = MSYM_SUCCESS;
     int length = 0, gesl = 0;
     for(int i = 0;i < esl;i++) length += es[i].length;
@@ -132,15 +132,15 @@ msym_error_t splitPointGroupEquivalenceSets(msym_point_group_t *pg, int esl, msy
         msym_equivalence_set_t *pes = NULL;
         int pesl = 0;
         if(MSYM_SUCCESS != (ret = partitionPointGroupEquivalenceSets(pg, es[i].length, es[i].elements, es[i].elements - ep + pelements, &pesl, &pes, thresholds))) goto err;
-        ges = realloc(ges, sizeof(msym_equivalence_set_t[gesl+pesl]));
-        memcpy(&ges[gesl], pes, sizeof(msym_equivalence_set_t[pesl]));
+        ges = realloc(ges, sizeof(msym_equivalence_set_t)*(gesl+pesl));
+        memcpy(&ges[gesl], pes, sizeof(msym_equivalence_set_t)*pesl);
         free(pes);
         gesl += pesl;
     }
     
-    ges = realloc(ges, sizeof(msym_equivalence_set_t[gesl]) + sizeof(msym_element_t *[length]));
+    ges = realloc(ges, sizeof(msym_equivalence_set_t)*gesl + sizeof(msym_element_t *)*length);
     ep = (msym_element_t **) &ges[gesl];
-    memcpy(ep, pelements, sizeof(msym_element_t *[length]));
+    memcpy(ep, pelements, sizeof(msym_element_t *)*length);
     
     for(int i = 0;i < gesl;i++){
         ges[i].elements = ep;
@@ -158,17 +158,17 @@ err:
     return ret;
 }
 
-msym_error_t findPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[length], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds){
+msym_error_t findPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds){
     msym_error_t ret = MSYM_SUCCESS;
     msym_equivalence_set_t *ges = NULL;
     msym_element_t **pelements = calloc(length,sizeof(msym_element_t*));
     int gesl = 0;
     if(MSYM_SUCCESS != (ret = partitionPointGroupEquivalenceSets(pg, length, elements, pelements, &gesl, &ges, thresholds))) goto err;
     
-    ges = realloc(ges,sizeof(msym_equivalence_set_t[gesl]) + sizeof(msym_element_t *[length]));
+    ges = realloc(ges,sizeof(msym_equivalence_set_t)*gesl + sizeof(msym_element_t *)*length);
     msym_element_t **ep = (msym_element_t **) &ges[gesl];
     msym_element_t **epo = ep;
-    memcpy(ep, pelements, sizeof(msym_element_t *[length]));
+    memcpy(ep, pelements, sizeof(msym_element_t *)*length);
     for(int i = 0;i < gesl;i++){
         if(ep > epo + length){
             msymSetErrorDetails("Equivalence set pointer (%ld) extends beyond number of elements (%d)",ep-epo,length);
@@ -190,11 +190,11 @@ err:
 
 }
 
-msym_error_t partitionPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[length], msym_element_t *pelements[length], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds){
+msym_error_t partitionPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[], msym_element_t *pelements[], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds){
     msym_error_t ret = MSYM_SUCCESS;
     msym_equivalence_set_t *ges = calloc(length,sizeof(msym_equivalence_set_t));
-    int *eqi = malloc(sizeof(int[length]));
-    memset(eqi,-1,sizeof(int[length]));
+    int *eqi = malloc(sizeof(int)*length);
+    memset(eqi,-1,sizeof(int)*length);
     int gesl = 0, pelementsl = 0;
     for(int i = 0;i < length;i++){
         if(eqi[i] >= 0) continue;
@@ -258,7 +258,7 @@ err:
 
 }
 
-msym_error_t findEquivalenceSets(int length, msym_element_t *elements[length], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds) {
+msym_error_t findEquivalenceSets(int length, msym_element_t *elements[], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds) {
     msym_error_t ret = MSYM_SUCCESS;
     int sesl = 0;
     msym_equivalence_set_t *ses = NULL;
@@ -275,8 +275,8 @@ msym_error_t findEquivalenceSets(int length, msym_element_t *elements[length], m
             if(rsesl > 1){
                 ses[i].elements = rses[0].elements;
                 ses[i].length = rses[0].length;
-                ses = realloc(ses, sizeof(msym_equivalence_set_t[sesl+rsesl-1]));
-                memcpy(&ses[sesl], &rses[1], sizeof(msym_equivalence_set_t[rsesl-1]));
+                ses = realloc(ses, sizeof(msym_equivalence_set_t)*(sesl + rsesl - 1));
+                memcpy(&ses[sesl], &rses[1], sizeof(msym_equivalence_set_t)*(rsesl-1));
                 sesl += rsesl-1;
                 i--;
             }
@@ -284,11 +284,11 @@ msym_error_t findEquivalenceSets(int length, msym_element_t *elements[length], m
         }
     }
 
-    ses = realloc(ses, sizeof(msym_equivalence_set_t[sesl]) + sizeof(msym_element_t *[length]));
+    ses = realloc(ses, sizeof(msym_equivalence_set_t)*sesl + sizeof(msym_element_t *)*length);
     msym_element_t **ep = (msym_element_t **) &ses[sesl];
     
     for(int i = 0;i < sesl;i++){
-        memcpy(ep, ses[i].elements, sizeof(msym_element_t *[ses[i].length]));
+        memcpy(ep, ses[i].elements, sizeof(msym_element_t *)*(ses[i].length));
         ses[i].elements = ep;
         ep += ses[i].length;
     }
@@ -305,7 +305,7 @@ err:
 }
 
 
-msym_error_t partitionEquivalenceSets(int length, msym_element_t *elements[length], msym_element_t *pelements[length], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds) {
+msym_error_t partitionEquivalenceSets(int length, msym_element_t *elements[], msym_element_t *pelements[], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds) {
     
     int ns = 0, gd = geometryDegenerate(g);
     double *e = calloc(length,sizeof(double));
@@ -414,8 +414,8 @@ msym_error_t partitionEquivalenceSets(int length, msym_element_t *elements[lengt
     msym_element_t **pe = pelements;
     
     if(elements == pelements){
-        lelements = malloc(sizeof(msym_element_t *[length]));
-        memcpy(lelements, elements, sizeof(msym_element_t *[length]));
+        lelements = malloc(sizeof(msym_element_t *)*length);
+        memcpy(lelements, elements, sizeof(msym_element_t *)*length);
     }
     
     for(int i = 0, ni = 0; i < length;i++){
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.h b/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.h
index ee3ce81..f4511cf 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/equivalence_set.h
@@ -15,10 +15,10 @@
 #include "msym.h"
 #include "point_group.h"
 
-msym_error_t copyEquivalenceSets(int length, msym_equivalence_set_t es[length], msym_equivalence_set_t **ces);
-msym_error_t findEquivalenceSets(int length, msym_element_t *elements[length], msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
-msym_error_t findPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t *elements[length], int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
-msym_error_t splitPointGroupEquivalenceSets(msym_point_group_t *pg, int esl, msym_equivalence_set_t es[esl], int *sesl, msym_equivalence_set_t **ses, msym_thresholds_t *thresholds);
-msym_error_t generateEquivalenceSet(msym_point_group_t *pg, int length, msym_element_t elements[length], int *glength, msym_element_t **gelements, int *esl, msym_equivalence_set_t **es,msym_thresholds_t *thresholds);
+msym_error_t copyEquivalenceSets(int length, msym_equivalence_set_t *es, msym_equivalence_set_t **ces);
+msym_error_t findEquivalenceSets(int length, msym_element_t **elements, msym_geometry_t g, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
+msym_error_t findPointGroupEquivalenceSets(msym_point_group_t *pg, int length, msym_element_t **elements, int *esl, msym_equivalence_set_t **es, msym_thresholds_t *thresholds);
+msym_error_t splitPointGroupEquivalenceSets(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, int *sesl, msym_equivalence_set_t **ses, msym_thresholds_t *thresholds);
+msym_error_t generateEquivalenceSet(msym_point_group_t *pg, int length, msym_element_t *elements, int *glength, msym_element_t **gelements, int *esl, msym_equivalence_set_t **es,msym_thresholds_t *thresholds);
 
 #endif /* defined(__MSYM__EQUIVALENCE_SET_h) */
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/geometry.c b/libavogadro/src/extensions/symmetry/libmsym/src/geometry.c
index 56e9d68..4abce82 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/geometry.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/geometry.c
@@ -17,16 +17,16 @@
 
 #define SQR(x) ((x)*(x))
 
-void inertialTensor(int length, msym_element_t *elements[length], double cm[3], double e[3], double v[3][3], msym_thresholds_t *thresholds);
+void inertialTensor(int length, msym_element_t *elements[], double cm[3], double e[3], double v[3][3], msym_thresholds_t *thresholds);
 msym_geometry_t eigenvaluesToGeometry(double e[3], msym_thresholds_t *thresholds);
 
-msym_error_t findGeometry(int length, msym_element_t *elements[length], double cm[3], msym_thresholds_t *thresholds, msym_geometry_t *g, double e[3], double v[3][3]){
+msym_error_t findGeometry(int length, msym_element_t *elements[], double cm[3], msym_thresholds_t *thresholds, msym_geometry_t *g, double e[3], double v[3][3]){
     inertialTensor(length, elements, cm, e, v, thresholds);
     *g = eigenvaluesToGeometry(e,thresholds);
     return MSYM_SUCCESS;
 }
 
-msym_error_t findCenterOfMass(int length, msym_element_t *elements[length], double v[3]){
+msym_error_t findCenterOfMass(int length, msym_element_t *elements[], double v[3]){
     msym_error_t ret = MSYM_SUCCESS;
     double t = 0;
     v[0] = v[1] = v[2] = 0.0;
@@ -96,7 +96,7 @@ int geometryDegenerate(msym_geometry_t g){
     return !(g == PLANAR_IRREGULAR || g == ASSYMETRIC) && g != GEOMETRY_UNKNOWN;
 }
 
-void inertialTensor(int length, msym_element_t *elements[length], double cm[3], double e[3], double v[3][3], msym_thresholds_t *thresholds){
+void inertialTensor(int length, msym_element_t *elements[], double cm[3], double e[3], double v[3][3], msym_thresholds_t *thresholds){
     double Ixx = 0, Iyy = 0, Izz = 0, Ixy = 0, Ixz = 0, Iyz = 0;
     for(int i = 0; i < length; i++){
         msym_element_t *a = elements[i];
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/geometry.h b/libavogadro/src/extensions/symmetry/libmsym/src/geometry.h
index a3427bc..4d920fb 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/geometry.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/geometry.h
@@ -14,8 +14,8 @@
 #include <stdio.h>
 #include "msym.h"
 
-msym_error_t findGeometry(int length, msym_element_t *elements[length], double cm[3], msym_thresholds_t *thresholds, msym_geometry_t *g, double e[3], double v[3][3]);
-msym_error_t findCenterOfMass(int length, msym_element_t *elements[length], double v[3]);
+msym_error_t findGeometry(int length, msym_element_t **elements, double cm[3], msym_thresholds_t *thresholds, msym_geometry_t *g, double e[3], double v[3][3]);
+msym_error_t findCenterOfMass(int length, msym_element_t **elements, double v[3]);
 int geometryDegenerate(msym_geometry_t g);
 void printGeometry(msym_geometry_t g);
 
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/linalg.c b/libavogadro/src/extensions/symmetry/libmsym/src/linalg.c
index e2700ae..90298ee 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/linalg.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/linalg.c
@@ -24,9 +24,9 @@
 #define SQR(x) ((x)*(x))
 #define CUBE(x) ((x)*(x)*(x))
 
-void mleye(int l, double E[l][l]){
+void mleye(int l, double **E){
     
-    memset(E, 0, sizeof(double[l][l]));
+    memset(E, 0, sizeof(E));
     for(int i = 0;i < l;i++){
         E[i][i] = 1.0;
     }
@@ -181,7 +181,7 @@ void vproj(double v[3], double u[3], double vo[3]){
     vlproj(3, v, u, vo);
 }
 
-void vlproj(int l, double v[l], double u[l], double vo[l]){
+void vlproj(int l, double v[], double u[], double vo[]){
     vlscale(vldot(l,u,v)/vldot(l,u,u),l,u,vo);
 }
 
@@ -222,7 +222,7 @@ double vdot(double v1[3], double v2[3]) {
     
 }
 
-double vldot(int l, double v1[l], double v2[l]) {
+double vldot(int l, double v1[], double v2[]) {
     double d = 0;
     for(int i = 0; i < l; i++) d+= v1[i]*v2[i];
     return d;
@@ -234,7 +234,7 @@ void vadd(double v1[3],double v2[3], double vr[3]){
     vr[2] = v1[2] + v2[2];
 }
 
-void vladd(int l, double v1[l],double v2[l], double vr[l]){
+void vladd(int l, double v1[],double v2[], double vr[]){
     for(int i = 0; i < l;i++) vr[i] = v1[i] + v2[i];
 }
 
@@ -245,7 +245,7 @@ void vscale(double s,double v[3], double vr[3]){
     vr[2] = s*v[2];
 }
 
-void vlscale(double s,int l, double v[l], double vr[l]){
+void vlscale(double s,int l, double v[], double vr[]){
     for(int i = 0;i < l;i++) vr[i] = s*v[i];
 }
 
@@ -257,7 +257,7 @@ void mscale(double s,double m[3][3], double mr[3][3]){
     }
 }
 
-void mlscale(double s,int l, double m[l][l], double mr[l][l]){
+void mlscale(double s,int l, double **m, double **mr){
     for(int i=0; i<l; ++i){
         for(int j=0; j<l; ++j){
             mr[i][j] = s*m[i][j];
@@ -265,7 +265,7 @@ void mlscale(double s,int l, double m[l][l], double mr[l][l]){
     }
 }
 
-double mltrace(int l, double M[l][l]) {
+double mltrace(int l, double **M) {
     double trace = 0;
     for(int i = 0; i < l; i++) trace += M[i][i];
     return trace;
@@ -277,7 +277,7 @@ void vsub(double v1[3],double v2[3], double vr[3]){
     vr[2] = v1[2] - v2[2];
 }
 
-void vlsub(int l, double v1[l],double v2[l], double vr[l]){
+void vlsub(int l, double v1[],double v2[], double vr[]){
     for(int i = 0; i < l;i++) vr[i] = v1[i] - v2[i];
 }
 
@@ -285,7 +285,7 @@ double vabs(double v[3]){
     return sqrt(SQR(v[0])+SQR(v[1])+SQR(v[2]));
 }
 
-double vlabs(int l, double v[l]){
+double vlabs(int l, double v[]){
     double r = 0;
     for(int i = 0;i < l;i++) r += SQR(v[i]);
     return sqrt(r);
@@ -307,7 +307,7 @@ double vnorm(double v[3]){
     return norm;
 }
 
-double vlnorm(int l, double v[l]){
+double vlnorm(int l, double v[]){
     double norm = vlabs(l,v);
     if (norm != 0.0) {
         for(int i = 0; i < l;i++){
@@ -317,7 +317,7 @@ double vlnorm(int l, double v[l]){
     return norm;
 }
 
-double vlnorm2(int l, double v1[l], double v2[l]){
+double vlnorm2(int l, double v1[], double v2[]){
     double norm = vlabs(l,v1);
     if (norm != 0.0) {
         for(int i = 0; i < l;i++){
@@ -341,7 +341,7 @@ void vcopy(double vi[3], double vo[3]){
     vo[2] = vi[2];
 }
 
-void vlcopy(int l, double vi[l], double vo[l]){
+void vlcopy(int l, double vi[], double vo[]){
     for(int i = 0; i < l; i++) vo[i] = vi[i];
 }
 
@@ -355,8 +355,8 @@ void mvmul(double v[3], double m[3][3], double r[3]){
     r[2] = t[2];
 }
 
-void mvlmul(int r, int c, double M[r][c], double v[c], double vo[r]){
-    memset(vo, 0, sizeof(double[r]));
+void mvlmul(int r, int c, double **M, double v[], double vo[]){
+    memset(vo, 0, sizeof(vo));
     for(int i = 0; i < r; i++){
         for(int j = 0; j < c;j++){
             vo[i] += M[i][j]*v[j];
@@ -384,18 +384,18 @@ void mmmul(double A[3][3], double B[3][3], double C[3][3]){
     mcopy(T,C);
 }
 
-void mmtlmul(int rla, int cla, double A[rla][cla], int rlb, double B[rlb][cla], double C[rla][rlb]){
-    double (*T)[rlb] = malloc(sizeof(double[cla][rlb]));
+void mmtlmul(int rla, int cla, double **A, int rlb, double **B, double **C){
+    double (**T) = malloc(sizeof(double)*cla*rlb);
     mltranspose(rlb, cla, B, T);
     mmlmul(rla,cla,A,rlb,T,C);
     free(T);
 }
 
-void mmlmul(int rla, int cla, double A[rla][cla], int clb, double B[cla][clb], double C[rla][clb]){
+void mmlmul(int rla, int cla, double **A, int clb, double **B, double **C){
     
-    double (*T)[clb];
+    double (**T);
     if(A == C || B == C){
-        T = malloc(sizeof(double[rla][clb]));
+        T = malloc(sizeof(C));
     } else {
         T = C;
     }
@@ -430,7 +430,7 @@ int mequal(double A[3][3], double B[3][3], double t){
     return e;
 }
 
-void mlFilterSmall(int l, double A[l][l]){
+void mlFilterSmall(int l, double **A){
     for(int i = 0;i < l;i++){
         for(int j = 0;j < l;j++){
             if(fabs(A[i][j]) < DBL_EPSILON) A[i][j] = 0.0;
@@ -439,7 +439,7 @@ void mlFilterSmall(int l, double A[l][l]){
 }
 
 //only square matrixes for now
-void kron(int al, double A[al][al], int bl, double B[bl][bl], int cl, double C[cl][cl]){
+void kron(int al, double **A, int bl, double **B, int cl, double **C){
     for(int ai = 0; ai < al;ai++){
         for(int aj = 0; aj < al;aj++){
             for(int bi = 0; bi < bl;bi++){
@@ -451,7 +451,7 @@ void kron(int al, double A[al][al], int bl, double B[bl][bl], int cl, double C[c
     }
 }
 
-void vlprint(int l, double v[l]) {
+void vlprint(int l, double v[]) {
     printf("[");
     for(int i = 0;i < l;i++){
         printf("%lf%s",v[i],(i == (l - 1)) ? "]\n" : ";");
@@ -460,8 +460,8 @@ void vlprint(int l, double v[l]) {
 
 
 /* Graam-Schmidt */
-int mgs(int l, double M[l][l], double O[l][l], int n, double t){
-    double *tmp = malloc(sizeof(double[l]));
+int mgs(int l, double **M, double **O, int n, double t){
+    double *tmp = malloc(sizeof(double)*l);
     for(int i = 0; i < l;i++){
         if(vlabs(l,M[i]) < t){
             continue;
@@ -537,7 +537,7 @@ void madd(double A[3][3], double B[3][3], double C[3][3]){
     }
 }
 
-void mladd(int l, double A[l][l], double B[l][l], double C[l][l]){
+void mladd(int l, double **A, double **B, double **C){
     for(int i=0; i<l; ++i){
         for(int j=0; j<l; ++j){
             C[i][j] = A[i][j] + B[i][j];
@@ -580,7 +580,7 @@ void minv(double M[3][3], double I[3][3]){
     
 }
 
-void mlcopy(int l, double A[l][l], double B[l][l]){
+void mlcopy(int l, double **A, double **B){
     for(int i=0; i<l; ++i){
         for(int j=0; j<l; ++j){
             B[i][j] = A[i][j];
@@ -594,7 +594,7 @@ void mtranspose(double A[3][3], double B[3][3]){
 
 
 
-void mltranspose(int rl, int cl, double A[rl][cl], double B[cl][rl]){
+void mltranspose(int rl, int cl, double **A, double **B){
     for(int r = 0; r < rl;r++){
         for(int c = 0; c < cl;c++){
             B[c][r] = A[r][c];
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/linalg.h b/libavogadro/src/extensions/symmetry/libmsym/src/linalg.h
index aae52f8..358abf2 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/linalg.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/linalg.h
@@ -11,38 +11,38 @@
 #ifndef __MSYM_LINALG_h
 #define __MSYM_LINALG_h
 
-void mleye(int l, double E[l][l]);
+void mleye(int l, double **E);
 int vzero(double v[3], double t);
 int vparallel(double v1[3], double v2[3], double t);
 int vperpendicular(double v1[3], double v2[3], double t);
 double vnorm(double v[3]);
 double vnorm2(double v1[3],double v2[3]);
-double vlnorm(int l, double v[l]);
-double vlnorm2(int l, double v1[l], double v2[l]);
+double vlnorm(int l, double *v);
+double vlnorm2(int l, double *v1, double *v2);
 double vabs(double v[3]);
-double vlabs(int l, double v[l]);
+double vlabs(int l, double *v);
 void vinv(double v[3]);
 void vcopy(double vi[3], double vo[3]);
-void vlcopy(int l, double vi[l], double vo[l]);
+void vlcopy(int l, double *vi, double *vo);
 void vcross(double v1i[3],double v2i[3], double vr[3]);
 double vcrossnorm(double[3],double[3], double[3]);
 double vdot(double[3],double[3]);
-double vldot(int l, double v1[l], double v2[l]);
+double vldot(int l, double *v1, double *v2);
 int vequal(double v1[3],double v2[3], double t);
 void vadd(double[3],double[3], double[3]);
-void vladd(int l, double v1[l],double v2[l], double vr[l]);
+void vladd(int l, double *v1,double *v2, double *vr);
 void madd(double A[3][3], double B[3][3], double C[3][3]);
-void mladd(int l, double A[l][l], double B[l][l], double C[l][l]);
+void mladd(int l, double **A, double **B, double **C);
 void vsub(double[3],double[3], double[3]);
-void vlsub(int l, double v1[l],double v2[l], double vr[l]);
+void vlsub(int l, double *v1,double *v2, double *vr);
 void vscale(double,double[3], double[3]);
-void vlscale(double s,int l, double v[l], double vr[l]);
+void vlscale(double s,int l, double *v, double *vr);
 void mscale(double s,double m[3][3], double mr[3][3]);
-void mlscale(double s,int l, double m[l][l], double mr[l][l]);
+void mlscale(double s,int l, double **m, double **mr);
 void vproj_plane(double v[3], double plane[3], double proj[3]);
 void vproj(double v[3], double u[3], double vo[3]);
-void vlproj(int l, double v[l], double u[l], double vo[l]);
-void vlprint(int l, double v[l]);
+void vlproj(int l, double *v, double *u, double *vo);
+void vlprint(int l, double *v);
 void vcomplement(double v1[3], double v2[3]);
 double vangle(double[3],double[3]);
 void vrotate(double theta, double v[3], double axis[3], double vr[3]);
@@ -50,23 +50,23 @@ void mrotate(double theta, double axis[3], double m[3][3]);
 void vreflect(double v[3], double axis[3], double vr[3]);
 void mreflect(double axis[3], double m[3][3]);
 void mvmul(double v[3], double m[3][3], double r[3]);
-void mvlmul(int r, int c, double M[r][c], double v[c], double vo[r]);
+void mvlmul(int r, int c, double **M, double *v, double *vo);
 void mmmul(double A[3][3], double B[3][3], double C[3][3]);
-void mmlmul(int rla, int cla, double A[rla][cla], int clb, double B[cla][clb], double C[rla][clb]);
-void mmtlmul(int rla, int cla, double A[rla][cla], int rlb, double B[rlb][cla], double C[rla][rlb]);
+void mmlmul(int rla, int cla, double **A, int clb, double **B, double **C);
+void mmtlmul(int rla, int cla, double **A, int rlb, double **B, double **C);
 void minv(double M[3][3], double I[3][3]);
 double mdet(double M[3][3]);
 void mcopy(double A[3][3], double B[3][3]);
-void mlcopy(int l, double A[l][l], double B[l][l]);
+void mlcopy(int l, double **A, double **B);
 void mtranspose(double A[3][3], double B[3][3]);
-void mltranspose(int rl, int cl, double A[rl][cl], double B[cl][rl]);
-double mltrace(int l, double M[l][l]);
+void mltranspose(int rl, int cl, double **A, double **B);
+double mltrace(int l, double **M);
 int mequal(double A[3][3], double B[3][3], double t);
 void malign(double v[3], double axis[3], double m[3][3]);
 int ipow(int b, int e);
-int mgs(int l, double M[l][l], double O[l][l], int n, double t);
-void kron(int al, double A[al][al], int bl, double B[bl][bl], int cl, double C[cl][cl]);
-void mlFilterSmall(int l, double A[l][l]);
+int mgs(int l, double **M, double **O, int n, double t);
+void kron(int al, double **A, int bl, double **B, int cl, double **C);
+void mlFilterSmall(int l, double **A);
 void jacobi(double m[6], double e[3], double ev[3][3], double threshold);
 
 
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/msym.c b/libavogadro/src/extensions/symmetry/libmsym/src/msym.c
index 1fccdaa..9c8a6a2 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/msym.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/msym.c
@@ -109,7 +109,7 @@ err:
     return ret;
 }
 
-msym_error_t msymGenerateElements(msym_context ctx, int length, msym_element_t elements[length]){
+msym_error_t msymGenerateElements(msym_context ctx, int length, msym_element_t elements[]){
     msym_error_t ret = MSYM_SUCCESS;
     msym_point_group_t *pg = NULL;
     msym_thresholds_t *t = NULL;
@@ -475,7 +475,7 @@ err:
     return ret;
 }
 
-msym_error_t msymGetOrbitalSubspaces(msym_context ctx, int l, double c[l][l]){
+msym_error_t msymGetOrbitalSubspaces(msym_context ctx, int l, double **c){
     msym_error_t ret = MSYM_SUCCESS;
     msym_subspace_t *ss = NULL;
     msym_orbital_t *basis = NULL;
@@ -512,7 +512,7 @@ err:
 
 }
 
-msym_error_t msymSymmetrizeOrbitals(msym_context ctx, int l, double c[l][l]){
+msym_error_t msymSymmetrizeOrbitals(msym_context ctx, int l, double **c){
     msym_error_t ret = MSYM_SUCCESS;
 
     msym_point_group_t *pg = NULL;
@@ -521,7 +521,7 @@ msym_error_t msymSymmetrizeOrbitals(msym_context ctx, int l, double c[l][l]){
     msym_thresholds_t *t = NULL;
     int *span = NULL;
     
-    double (*symc)[l] = NULL;
+    double (**symc) = NULL;
     
     int ssl = 0, basisl = 0;
     
@@ -552,7 +552,7 @@ msym_error_t msymSymmetrizeOrbitals(msym_context ctx, int l, double c[l][l]){
     }
     
     
-    symc = malloc(sizeof(double[l][l]));
+    symc = malloc(sizeof(c));
     
     start = clock();
 
@@ -565,8 +565,8 @@ msym_error_t msymSymmetrizeOrbitals(msym_context ctx, int l, double c[l][l]){
     
     end = clock();
     
-    memcpy(c,symc,sizeof(double[l][l]));
-    
+    //memcpy(c,symc,sizeof(double[l][l]));
+	memcpy(c, symc, sizeof(c));
     time = (double)(end - start) / CLOCKS_PER_SEC;
     
     printf("time: %lf seconds to symmetrize %d orbitals\n",time,basisl);
@@ -620,7 +620,7 @@ msym_error_t msymFindEquivalenceSetPermutations(msym_context ctx) {
         }
     }*/
     
-    esv = malloc(sizeof(double (*[pg->order])[3]));
+    esv = malloc(sizeof(double (*)[3])*pg->order);
     for(int i = 0; i < esl;i++){
         for(int j = 0; j < es[i].length;j++){
             esv[j] = &es[i].elements[j]->v;
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/orbital.c b/libavogadro/src/extensions/symmetry/libmsym/src/orbital.c
index 143b4de..e67e60c 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/orbital.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/orbital.c
@@ -21,12 +21,12 @@
 #include "permutation.h"
 #include "point_group.h"
 
-void printTransform(int r, int c, double M[r][c]);
-void tabPrintTransform(int r, int c, double M[r][c],int indent);
+void printTransform(int r, int c, double **M);
+void tabPrintTransform(int r, int c, double **M,int indent);
 void printSubspaceTree(CharacterTable *ct, msym_subspace_t *ss,int indent);
 void tabprintf(char *format, int indent, ...);
 
-msym_error_t getOrbitalSubspaceCoefficients(msym_subspace_t *ss, int basisl, msym_orbital_t basis[basisl], int *offset, double c[basisl][basisl]);
+msym_error_t getOrbitalSubspaceCoefficients(msym_subspace_t *ss, int basisl, msym_orbital_t basis[], int *offset, double **c);
 int filterSubspace(msym_subspace_t *ss);
 
 
@@ -134,11 +134,17 @@ err:
 }
 
 //We can split this into a part for each l and just build the subspaces, and we already have the permutation matrix so
-msym_error_t findProjection(CharacterTable *ct, int sopsl, msym_symmetry_operation_t sops[sopsl], msym_permutation_t perm[sopsl], int l, msym_orbital_t *basis[2*l+1]){
+msym_error_t findProjection(CharacterTable *ct, int sopsl, msym_symmetry_operation_t sops[], msym_permutation_t perm[], int l, msym_orbital_t *basis[]){
     msym_error_t ret = MSYM_SUCCESS;
     int kdim = ipow(3,l), setl = perm[0].p_length;
-    double (*mkron)[kdim] = malloc(sizeof(double[kdim][kdim]));
-    double (*mperm)[setl] = malloc(sizeof(double[setl][setl]));
+	double(**mkron) = malloc(sizeof(double *) * kdim);
+	for (int i = 0; i < kdim; i++) {
+		mkron[i] = malloc(sizeof(double) * kdim);
+	}
+	double(**mperm) = malloc(sizeof(double *) * setl);
+	for (int i = 0; i < setl; i++) {
+		mperm[i] = malloc(sizeof(double) * setl);
+	}
     
     for(int m = 0; m < 2*l+1;m++){
         permutationMatrix(&perm[m], mperm);
@@ -149,11 +155,11 @@ msym_error_t findProjection(CharacterTable *ct, int sopsl, msym_symmetry_operati
     return ret;
 }
 
-msym_error_t generateOrbitalTransforms(int sopsl, msym_symmetry_operation_t sops[sopsl], int l, double transform[sopsl][2*l+1][2*l+1]){
+msym_error_t generateOrbitalTransforms(int sopsl, msym_symmetry_operation_t sops[], int l, double ***transform){
     msym_error_t ret = MSYM_SUCCESS;
     int kdim = ipow(3,l), norbs = 2*l+1;
-    double (*mkron)[kdim][kdim] = malloc(sizeof(double[2][kdim][kdim]));
-    double (*poly)[kdim] = malloc(sizeof(double[norbs][kdim]));
+    double (***mkron) = malloc(sizeof(double)*2*kdim*kdim);
+    double (**poly) = malloc(sizeof(double)*norbs*kdim);
     
     for(int m = -l; m <= l;m++){
         if(MSYM_SUCCESS != (ret = orbitalPolynomial(l,m,poly[m+l]))) goto err;
@@ -187,7 +193,7 @@ err:
     return ret;
 }
 
-msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, int basisl, msym_orbital_t basis[basisl], msym_thresholds_t *thresholds, int *subspacel, msym_subspace_t **subspace, int **pspan){
+msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, int basisl, msym_orbital_t basis[], msym_thresholds_t *thresholds, int *subspacel, msym_subspace_t **subspace, int **pspan){
     msym_error_t ret = MSYM_SUCCESS;
     int lmax = -1, nmax = -1, eslmax = -1;
     for(int i = 0;i < basisl;i++){
@@ -200,16 +206,16 @@ msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equi
     for(int i = 0;i < esl;i++) eslmax = es[i].length > eslmax ? es[i].length : eslmax;
     
     struct _ltransforms {int d; void *t;} *lts = calloc(lmax+1,sizeof(struct _ltransforms));
-    double (*mkron)[(2*lmax+1)*pg->order] = malloc(sizeof(double[(2*lmax+1)*pg->order][(2*lmax+1)*pg->order]));
-    double (*mperm)[pg->order] = malloc(sizeof(double[pg->order][pg->order]));
+    double (**mkron) = malloc(sizeof(double)*((2 * lmax + 1)*pg->order)*((2 * lmax + 1)*pg->order));
+    double (**mperm) = malloc(sizeof(double)*pg->order*pg->order);
     
-    double (*mproj)[pg->ct->l+1][(2*lmax+1)*pg->order][(2*lmax+1)*pg->order] = malloc(sizeof(double[lmax+1][pg->ct->l+1][(2*lmax+1)*pg->order][(2*lmax+1)*pg->order]));
-    double (*lspan)[pg->ct->l] = malloc(sizeof(double[lmax+1][pg->ct->l]));
+    double (****mproj) = malloc(sizeof(double)*((2 * lmax + 1)*pg->order)*((2 * lmax + 1)*pg->order)*(pg->ct->l+1)*(lmax+1));
+    double (**lspan) = malloc(sizeof(double)*(lmax+1)*(pg->ct->l));
     int (*ispan) = calloc(pg->ct->l,sizeof(int));
     int *aspan = calloc(pg->ct->l,sizeof(int));
-    int *nl = malloc(sizeof(int[lmax+1]));
+    int *nl = malloc(sizeof(int)*(lmax+1));
     
-    msym_orbital_t *(*omap)[nmax][lmax][2*lmax+1] = malloc(sizeof(msym_orbital_t *[eslmax][nmax+1][lmax+1][2*lmax+1]));
+    msym_orbital_t ****(*omap)= malloc(sizeof(msym_orbital_t *)*(eslmax)*(nmax+1)*(lmax+1)*(2*lmax+1));
     
     *subspace = NULL;
     
@@ -223,23 +229,23 @@ msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equi
     
     for(int l = 0; l <= lmax;l++){
         lts[l].d = 2*l+1;
-        lts[l].t = malloc(sizeof(double[pg->sopsl][lts[l].d][lts[l].d]));
+        lts[l].t = malloc(sizeof(double)*(lts[1].d)*(lts[1].d)*(pg->sopsl));
         if(MSYM_SUCCESS != (ret = generateOrbitalTransforms(pg->sopsl, pg->sops, l, lts[l].t))) goto err;
     }
     
     for(int i = 0; i < esl;i++){
         int esilmax = -1, esinmax = -1;
         
-        memset(nl,0,sizeof(int[lmax+1]));
+        memset(nl,0,sizeof(int)*(lmax+1));
         for(int j = 0;j < es[i].elements[0]->aol;j++){
             esilmax = esilmax < es[i].elements[0]->ao[j]->l ? es[i].elements[0]->ao[j]->l : esilmax;
             esinmax = esinmax < es[i].elements[0]->ao[j]->n ? es[i].elements[0]->ao[j]->n : esinmax;
             nl[es[i].elements[0]->ao[j]->l] += es[i].elements[0]->ao[j]->m == 0;
         }
         
-        msym_orbital_t *(*esomap)[esinmax+1][esilmax+1][2*esilmax+1] = omap;
+        msym_orbital_t ****(*esomap)= omap;
         
-        memset(esomap,0,sizeof(msym_orbital_t *[es->length][esinmax+1][esilmax+1][2*esilmax+1]));
+        memset(esomap,0,sizeof(msym_orbital_t *)*(es->length)*(esinmax+1)*(esilmax+1)*(2*esilmax+1));
         for(int a = 0;a < es[i].length;a++){
             for(int ao = 0;ao < es[i].elements[a]->aol;ao++){
                 msym_orbital_t *o = es[i].elements[a]->ao[ao];
@@ -247,16 +253,16 @@ msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equi
             }
         }
         
-        memset(lspan,0,sizeof(double[lmax+1][pg->ct->l]));
+        memset(lspan,0,sizeof(double)*(lmax+1)*(pg->ct->l));
         
         for(int l = 0;l <= esilmax;l++){
             int d = es[i].length*lts[l].d;
-            double (*mlproj)[d][d] = mproj[l];
-            memset(mlproj,0,sizeof(double[pg->ct->l][d][d]));
-            memset(ispan,0,sizeof(int[pg->ct->l]));
+            double (***mlproj) = mproj[l];
+            memset(mlproj,0,sizeof(double)*d*d*pg->ct->l);
+            memset(ispan,0,sizeof(int)*pg->ct->l);
             
             for(int s = 0;s < pg->sopsl;s++){
-                double (*lt)[lts[l].d][lts[l].d] = lts[l].t;
+                double (***lt) = lts[l].t;
                 permutationMatrix(&perm[i][s], mperm);
                 kron(perm[i][s].p_length,mperm,lts[l].d,lt[s],d,mkron);
                 
@@ -269,7 +275,7 @@ msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equi
                     mladd(d, mlproj[pg->ct->l], mlproj[k], mlproj[k]); //Could do this based on the span later, but it's not a huge amount of work
                 }
             }
-            memset(mlproj[pg->ct->l],0,sizeof(double[d][d]));
+            memset(mlproj[pg->ct->l],0,sizeof(double)*d*d);
             int nirrepl = 0;
             for(int k = 0;k < pg->ct->l;k++){
                 int lirrepl = nirrepl;
@@ -290,7 +296,7 @@ msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equi
                 ss->irrep = k;
                 
                 if(ispan[k] > 0){
-                    ss->subspace = realloc(ss->subspace, sizeof(msym_subspace_t[ss->subspacel+nl[l]]));
+                    ss->subspace = realloc(ss->subspace, sizeof(msym_subspace_t)*(ss->subspacel+nl[l]));
                     for(int n = l+1; n <= esinmax;n++){
                         if(esomap[0][n][l][0] == NULL) continue;
                         
@@ -301,13 +307,13 @@ msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equi
                         nss->type = ATOMIC_ORBITAL;
                         nss->irrep = ss->irrep;
                         nss->d = ispan[k]*pg->ct->irrep[k].d;
-                        double (*space)[d] = malloc(sizeof(double[nss->d][d]));
+                        double (**space) = malloc(sizeof(double)*d*nss->d);
                         for(int dim = 0; dim < ss->subspace[ss->subspacel].d;dim++){
                             vlnorm2(d, mlproj[pg->ct->l][lirrepl+dim], space[dim]);
                         }
                         nss->space = (double*) space;
                         nss->basisl = 0;
-                        nss->basis.o = malloc(sizeof(msym_orbital_t *[d]));
+                        nss->basis.o = malloc(sizeof(msym_orbital_t *)*d);
                         for(int e = 0;e < es[i].length;e++){
                             for(int m = -l;m <= l;m++){
                                 nss->basis.o[nss->basisl++] = esomap[e][n][l][m+l];
@@ -371,10 +377,10 @@ err:
     return ret;
 }
 
-msym_error_t getOrbitalSubspaces(int ssl, msym_subspace_t ss[ssl], int basisl, msym_orbital_t basis[basisl], double c[basisl][basisl]){
+msym_error_t getOrbitalSubspaces(int ssl, msym_subspace_t ss[], int basisl, msym_orbital_t basis[], double **c){
     msym_error_t ret = MSYM_SUCCESS;
     int index = 0;
-    memset(c,0,sizeof(double[basisl][basisl]));
+    memset(c,0,sizeof(c));
     for(int i = 0;i < ssl;i++){
         if(MSYM_SUCCESS != (ret = getOrbitalSubspaceCoefficients(&ss[i],basisl,basis,&index,c))) goto err;
     }
@@ -390,7 +396,7 @@ err:
     return ret;
 }
 
-msym_error_t getOrbitalSubspaceCoefficients(msym_subspace_t *ss, int basisl, msym_orbital_t basis[basisl], int *offset, double c[basisl][basisl]){
+msym_error_t getOrbitalSubspaceCoefficients(msym_subspace_t *ss, int basisl, msym_orbital_t basis[], int *offset, double **c){
     msym_error_t ret = MSYM_SUCCESS;
     
     int index = *offset;
@@ -401,7 +407,7 @@ msym_error_t getOrbitalSubspaceCoefficients(msym_subspace_t *ss, int basisl, msy
     }
     
     if(ss->subspacel == 0){
-        double (*space)[ss->basisl] = (double (*)[ss->basisl]) ss->space;
+        double (**space) =  ss->space;
         if(index+ss->d > basisl) {
             msymSetErrorDetails("Generated subspaces (%d) is larger than basis length (%d)",index+ss->d,basisl);
             ret = MSYM_INVALID_SUBSPACE;
@@ -443,7 +449,7 @@ int filterSubspace(msym_subspace_t *ss){
                     break;
                 } else {
                     memcpy(&ss->subspace[i], &ss->subspace[ss->subspacel], sizeof(msym_subspace_t));
-                    ss->subspace = realloc(ss->subspace, sizeof(msym_subspace_t[ss->subspacel]));
+                    ss->subspace = realloc(ss->subspace, sizeof(msym_subspace_t)*ss->subspacel);
                     i--;
                 }
                 
@@ -481,7 +487,7 @@ void printSubspaceTree(CharacterTable *ct, msym_subspace_t *ss,int indent){
             tabprintf("", indent);
             for(int i = 0;i < ss->basisl;i++) printf("  %s\t",ss->basis.o[i]->name);
             printf("\n");
-            double (*space)[ss->basisl] = (double (*)[ss->basisl]) ss->space;
+            double (**space) =  ss->space;
             tabPrintTransform(ss->d,ss->basisl,space,indent);
         } else {
             tabprintf("No subspaces spaned\n", indent);
@@ -503,8 +509,8 @@ void tabprintf(char *format, int indent, ...){
 
 
 //Density matrix without occupation numbers
-void densityMatrix(int l, double M[l][l], double D[l][l]){
-    memset(D,0,sizeof(double[l][l]));
+void densityMatrix(int l, double **M, double **D){
+    memset(D,0,sizeof(D));
     for(int i = 0; i < l;i++){
         for(int j = 0;j < l;j++){
             for(int k = 0;k < l;k++){
@@ -518,7 +524,7 @@ void printOrbital(msym_orbital_t *orb){
     printf("Orbital(%d,%d,%d) : %s\n",orb->n, orb->l, orb->m, orb->name);
 }
 
-void printTransform(int r, int c, double M[r][c]) {
+void printTransform(int r, int c, double **M) {
     
     printf("\n[");
     for(int i = 0;i < r;i++){
@@ -534,7 +540,7 @@ void printTransform(int r, int c, double M[r][c]) {
     
 }
 
-void tabPrintTransform(int r, int c, double M[r][c],int indent) {
+void tabPrintTransform(int r, int c, double **M,int indent) {
     if(r == 0 || c == 0) {tabprintf("[]\n",indent);return;}
     //printf("\n");
     tabprintf("[",indent);
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/orbital.h b/libavogadro/src/extensions/symmetry/libmsym/src/orbital.h
index 4306fef..e86f062 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/orbital.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/orbital.h
@@ -52,10 +52,10 @@ typedef struct {
 msym_error_t orbitalFromName(char *, msym_orbital_t *orb);
 msym_error_t orbitalFromQuantumNumbers(int n, int l, int m, msym_orbital_t *orb);
 void printOrbital(msym_orbital_t *orb);
-msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, int basisl, msym_orbital_t basis[basisl], msym_thresholds_t *thresholds, int *subspacel, msym_subspace_t **subspace, int **pspan);
-msym_error_t generateOrbitalTransforms(int sopsl, msym_symmetry_operation_t sops[sopsl], int l, double transform[sopsl][2*l+1][2*l+1]);
+msym_error_t generateOrbitalSubspaces(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, int basisl, msym_orbital_t *basis, msym_thresholds_t *thresholds, int *subspacel, msym_subspace_t **subspace, int **pspan);
+msym_error_t generateOrbitalTransforms(int sopsl, msym_symmetry_operation_t *sops, int l, double ***transform);
 void freeSubspace(msym_subspace_t *ss);
-msym_error_t getOrbitalSubspaces(int ssl, msym_subspace_t ss[ssl],int basisl, msym_orbital_t basis[basisl], double c[basisl][basisl]);
+msym_error_t getOrbitalSubspaces(int ssl, msym_subspace_t *ss,int basisl, msym_orbital_t *basis, double **c);
 
 void printSubspace(CharacterTable *ct, msym_subspace_t *ss);
 
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/permutation.c b/libavogadro/src/extensions/symmetry/libmsym/src/permutation.c
index 3dd89df..86905b1 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/permutation.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/permutation.c
@@ -25,13 +25,13 @@ void freePermutationData(msym_permutation_t *perm){
     }
 }
 
-msym_error_t findPermutation(msym_symmetry_operation_t *sop, int l, double (*v[l])[3], msym_thresholds_t *t, msym_permutation_t *perm){
+msym_error_t findPermutation(msym_symmetry_operation_t *sop, int l, double (*v[])[3], msym_thresholds_t *t, msym_permutation_t *perm){
     msym_error_t ret = MSYM_SUCCESS;
     double m[3][3];
     symmetryOperationMatrix(sop, m);
     
-    perm->p = malloc(sizeof(int[l]));
-    memset(perm->p, -1, sizeof(int[l]));
+    perm->p = malloc(sizeof(int)*l);
+    memset(perm->p, -1, sizeof(int)*l);
     perm->p_length = l;
     
     for(int i = 0; i < l;i++){
@@ -70,18 +70,18 @@ typedef struct _perm_subgroup {
 
 
 
-msym_error_t findPermutationSubgroups(int l, msym_permutation_t perm[l], int sgmax, msym_symmetry_operation_t *sops, int *subgroupl, msym_subgroup_t **subgroup){
+msym_error_t findPermutationSubgroups(int l, msym_permutation_t perm[], int sgmax, msym_symmetry_operation_t *sops, int *subgroupl, msym_subgroup_t **subgroup){
     msym_error_t ret = MSYM_SUCCESS;
     perm_subgroup_t *group = calloc(l, sizeof(perm_subgroup_t));
     
-    int *isops = malloc(sizeof(int[l]));
-    int *msops = malloc(sizeof(int[l]));
+    int *isops = malloc(sizeof(int)*l);
+    int *msops = malloc(sizeof(int)*l);
     int gl = 0;
     
     for(int i = 0;i < l;i++){
         if((sops[i].power == 1 && (sops[i].type == PROPER_ROTATION || sops[i].type == IMPROPER_ROTATION)) || sops[i].type == INVERSION || sops[i].type == REFLECTION){
             msym_permutation_cycle_t* c = perm[i].c;
-            memset(msops, 0, sizeof(int[l]));
+            memset(msops, 0, sizeof(int)*l);
             group[gl].sopsl = c->l;
             group[gl].sops = calloc(c->l, sizeof(int));
             group[gl].subgroup[0] = group[gl].subgroup[1] = -1;
@@ -105,11 +105,11 @@ msym_error_t findPermutationSubgroups(int l, msym_permutation_t perm[l], int sgm
     for(int i = 0;i < gl && gl < sgmax;i++){
         for(int j = i+1;j < gl && gl < sgmax;j++){
             int minl = group[i].sopsl < group[j].sopsl ? group[i].sopsl : group[j].sopsl;
-            if(0 == memcmp(group[i].sops,group[j].sops,sizeof(int[minl]))) continue;
+            if(0 == memcmp(group[i].sops,group[j].sops,sizeof(int)*minl)) continue;
             
             int n = 0;
-            memset(isops, 0, sizeof(int[l]));
-            memset(msops, 0, sizeof(int[l]));
+            memset(isops, 0, sizeof(int)*l);
+            memset(msops, 0, sizeof(int)*l);
             
             for(int k = 0;k < group[i].sopsl;k++){
                 int s = group[i].sops[k];
@@ -138,7 +138,7 @@ msym_error_t findPermutationSubgroups(int l, msym_permutation_t perm[l], int sgm
             
             if(n < l && n > 1) {
                 n = 0;
-                memset(isops, 0, sizeof(int[l]));
+                memset(isops, 0, sizeof(int)*l);
 
                 for(int k = 0;k < l;k++){
                     if(msops[k]){
@@ -148,15 +148,15 @@ msym_error_t findPermutationSubgroups(int l, msym_permutation_t perm[l], int sgm
                 }
                 int f;
                 for(f = 0;f < gl;f++){
-                    if(group[f].sopsl == n && 0 == memcmp(group[f].sops, isops, sizeof(int[n]))){
+                    if(group[f].sopsl == n && 0 == memcmp(group[f].sops, isops, sizeof(int)*n)){
                         break;
                     }
                 }
                 if(f == gl){
-                    group = realloc(group, sizeof(perm_subgroup_t[gl+1]));
+                    group = realloc(group, sizeof(perm_subgroup_t)*(gl+1));
                     group[gl].sopsl = n;
-                    group[gl].sops = malloc(sizeof(int[n]));
-                    memcpy(group[gl].sops, isops, sizeof(int[n]));
+                    group[gl].sops = malloc(sizeof(int)*n);
+                    memcpy(group[gl].sops, isops, sizeof(int)*n);
                     group[gl].subgroup[0] = i;
                     group[gl].subgroup[1] = j;
                     gl++;
@@ -190,19 +190,19 @@ err:
     return ret;
 }
 
-msym_error_t findSymmetryOperationPermutations(int l, msym_symmetry_operation_t sops[l], msym_thresholds_t *t, msym_permutation_t **rperm){
+msym_error_t findSymmetryOperationPermutations(int l, msym_symmetry_operation_t sops[], msym_thresholds_t *t, msym_permutation_t **rperm){
     
     msym_error_t ret = MSYM_SUCCESS;
     //Don't block allocate this, it's a pain to keep track of the pointers
-    msym_permutation_t *permutations = malloc(sizeof(msym_permutation_t[l]));
+    msym_permutation_t *permutations = malloc(sizeof(msym_permutation_t)*l);
     
     for(int i = 0; i < l;i++){
-        permutations[i].p = malloc(sizeof(int[l]));
-        memset(permutations[i].p, -1, sizeof(int[l]));
+        permutations[i].p = malloc(sizeof(int)*l);
+        memset(permutations[i].p, -1, sizeof(int)*l);
         permutations[i].p_length = l;
     }
     
-    double (*msops)[3][3] = malloc(sizeof(double[l][3][3]));
+    double (*msops)[3][3] = malloc(sizeof(double[3][3])*l);
     
     for(int i = 0; i < l;i++){
         symmetryOperationMatrix(&sops[i], msops[i]);
@@ -257,13 +257,13 @@ err:
 msym_error_t setPermutationCycles(msym_permutation_t *perm){
     msym_error_t ret = MSYM_SUCCESS;
     int l = perm->p_length;
-    int *icycle = malloc(sizeof(int[l]));
-    int *pcycle = malloc(sizeof(int[l]));
-    int *lcycle = malloc(sizeof(int[l]));
+    int *icycle = malloc(sizeof(int)*l);
+    int *pcycle = malloc(sizeof(int)*l);
+    int *lcycle = malloc(sizeof(int)*l);
     
     int cl = 0;
-    memset(icycle, -1,sizeof(int[l]));
-    memset(lcycle,  0,sizeof(int[l]));
+    memset(icycle, -1,sizeof(int)*l);
+    memset(lcycle,  0,sizeof(int)*l);
     
     perm->c = NULL;
     perm->c_length = 0;
@@ -285,7 +285,7 @@ msym_error_t setPermutationCycles(msym_permutation_t *perm){
         cl++;
     }
     perm->c_length = cl;
-    perm->c = malloc(sizeof(msym_permutation_cycle_t[cl]));
+    perm->c = malloc(sizeof(msym_permutation_cycle_t)*cl);
     for(int c = 0; c < cl;c++){
         perm->c[c].l = lcycle[c];
         perm->c[c].s = pcycle[c];
@@ -300,9 +300,10 @@ err:
 
 
 //We need these as doubles later, so might as well, even though we could represent these with ALOT less memory
-void permutationMatrix(msym_permutation_t *perm, double m[perm->p_length][perm->p_length]){
-    memset(m, 0, sizeof(double[perm->p_length][perm->p_length]));
-    for(int i = 0;i < perm->p_length;i++){
+void permutationMatrix(msym_permutation_t *perm, double **m){
+    //memset(m, 0, sizeof(double[perm->p_length][perm->p_length]));
+	memset(m, 0, sizeof(m));
+	for(int i = 0;i < perm->p_length;i++){
         //m[i][perm->p[i]] = 1.0;
         m[perm->p[i]][i] = 1.0;
     }
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/permutation.h b/libavogadro/src/extensions/symmetry/libmsym/src/permutation.h
index 5e2c4ed..35f62f7 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/permutation.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/permutation.h
@@ -42,11 +42,11 @@ typedef struct _msym_permutation_morphism {
 } msym_permutation_morphism_t;
 
 
-msym_error_t findSymmetryOperationPermutations(int l, msym_symmetry_operation_t sops[l], msym_thresholds_t *t, msym_permutation_t **ret);
-msym_error_t findPermutation(msym_symmetry_operation_t *sop, int l, double (*v[l])[3], msym_thresholds_t *t, msym_permutation_t *perm);
+msym_error_t findSymmetryOperationPermutations(int l, msym_symmetry_operation_t *sops, msym_thresholds_t *t, msym_permutation_t **ret);
+msym_error_t findPermutation(msym_symmetry_operation_t *sop, int l, double (**v)[3], msym_thresholds_t *t, msym_permutation_t *perm);
 void freePermutationData(msym_permutation_t *perm);
-void permutationMatrix(msym_permutation_t *perm, double m[perm->p_length][perm->p_length]);
-msym_error_t findPermutationSubgroups(int l, msym_permutation_t perm[l], int sgmax, msym_symmetry_operation_t *sops, int *subgroupl, msym_subgroup_t **subgroup);
+void permutationMatrix(msym_permutation_t *perm, double **m);
+msym_error_t findPermutationSubgroups(int l, msym_permutation_t *perm, int sgmax, msym_symmetry_operation_t *sops, int *subgroupl, msym_subgroup_t **subgroup);
 
 void printPermutation(msym_permutation_t *perm);
 
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/point_group.c b/libavogadro/src/extensions/symmetry/libmsym/src/point_group.c
index ffcf128..e427426 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/point_group.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/point_group.c
@@ -689,7 +689,7 @@ msym_error_t pointGroupFromSubgroup(msym_subgroup_t *sg, msym_thresholds_t *thre
     pg->type = sg->type;
     pg->primary = sg->primary;
     pg->n = sg->n;
-    pg->sops = malloc(sizeof(msym_symmetry_operation_t[sg->sopsl]));
+    pg->sops = malloc(sizeof(msym_symmetry_operation_t)*sg->sopsl);
     pg->sopsl = sg->sopsl;
     memcpy(pg->name,sg->name,sizeof(pg->name));
     
@@ -998,7 +998,7 @@ msym_error_t generateSymmetryOperations(msym_point_group_t *pg, msym_thresholds_
     msym_error_t ret = MSYM_SUCCESS;
     double origo[3] = {0.0,0.0,0.0};
 
-    pg->sops = malloc(sizeof(msym_symmetry_operation_t[pg->order+1]));
+    pg->sops = malloc(sizeof(msym_symmetry_operation_t)*(pg->order+1));
     vcopy(origo,pg->sops[0].v);
     
     pg->sops[0].type = IDENTITY;
@@ -1076,7 +1076,7 @@ msym_error_t generateSymmetryOperations(msym_point_group_t *pg, msym_thresholds_
         goto err;
     }
     
-    pg->sops = realloc(pg->sops,sizeof(msym_symmetry_operation_t[pg->order]));
+    pg->sops = realloc(pg->sops,sizeof(msym_symmetry_operation_t)*pg->order);
     
     return ret;
     
@@ -1529,8 +1529,8 @@ void generateSymmetryOperationsIh(msym_point_group_t *pg){
 
 int classifySymmetryOperations(msym_point_group_t *pg){
     int c = 1;
-    double (*mop)[3][3] = malloc(sizeof(double[pg->sopsl][3][3]));
-    double (*imop)[3][3] = malloc(sizeof(double[pg->sopsl][3][3]));
+    double (*mop)[3][3] = malloc(sizeof(double[3][3])*pg->sopsl);
+    double (*imop)[3][3] = malloc(sizeof(double[3][3])*pg->sopsl);
     
     //There may be a better way to do this
     for(int i = 0; i < pg->sopsl;i++){
@@ -1695,12 +1695,12 @@ msym_error_t findCharacterTable(msym_point_group_t *pg){
         goto err;
     }
     
-    ct = realloc(ct, sizeof(CharacterTable)+sizeof(int[ct->l])+ct->l*sizeof(*ct->name));
+    ct = realloc(ct, sizeof(CharacterTable)+(sizeof(int)*ct->l)+ct->l*sizeof(*ct->name));
 
     ct->classc = (int*)(ct + 1);
     ct->name = (char (*)[6]) ((int *)ct->classc + ct->l);
         
-    memset(ct->classc, 0, sizeof(int[ct->l]));
+    memset(ct->classc, 0, sizeof(int)*ct->l);
     memset(ct->name, 0, ct->l*sizeof(*(ct->name)));
     for(int i = 0; i < pg->sopsl;i++){
         ct->classc[pg->sops[i].cla]++;
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.c b/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.c
index 99aa24c..d3082d5 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.c
@@ -19,7 +19,7 @@
 
 #define SQR(x) ((x)*(x))
 
-msym_error_t projectOntoSubspace(int d, double orb[d], msym_subspace_t *ss, msym_orbital_t basis[d], double mem[d], double proj[d]);
+msym_error_t projectOntoSubspace(int d, double orb[], msym_subspace_t *ss, msym_orbital_t basis[], double mem[], double proj[]);
 
 msym_error_t symmetrizeMoleculeProject(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, msym_thresholds_t *thresholds, double *err);
 msym_error_t symmetrizeMoleculeLinear(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, msym_thresholds_t *thresholds, double *err);
@@ -44,14 +44,14 @@ msym_error_t symmetrizeMolecule(msym_point_group_t *pg, int esl, msym_equivalenc
 msym_error_t symmetrizeMoleculeProject(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, msym_thresholds_t *thresholds, double *err){
     msym_error_t ret = MSYM_SUCCESS;
     double e = 0.0;
-    double (*v)[3] = malloc(sizeof(double[pg->order][3]));
+    double (*v)[3] = malloc(sizeof(double[3])*pg->order);
     for(int i = 0; i < esl;i++){
         if(es[i].length > pg->order){
             ret = MSYM_SYMMETRIZATION_ERROR;
             msymSetErrorDetails("Equivalence set (%d elements) larger than order of point group (%d)",es[i].length,pg->order);
             goto err;
         }
-        memset(v, 0, sizeof(double[pg->order][3]));
+        memset(v, 0, sizeof(double[3])*pg->order);
         for(int j = 0; j < pg->sopsl;j++){
             for(int k = 0; k < es[i].length;k++){
                 int p = perm[i][j].p[k];
@@ -79,8 +79,8 @@ err:
 msym_error_t symmetrizeMoleculeLinear(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, msym_thresholds_t *thresholds, double *err){
     msym_error_t ret = MSYM_SUCCESS;
     double e = 0.0;
-    double (*v)[3] = malloc(sizeof(double[pg->order][3]));
-    double (*vinf)[3] = malloc(sizeof(double[pg->order][3]));
+    double (*v)[3] = malloc(sizeof(double[3])*pg->order);
+    double (*vinf)[3] =  malloc(sizeof(double[3])*pg->order);
     msym_symmetry_operation_t *cinf = NULL;
     
     for(int i = 0; i < pg->sopsl;i++){
@@ -103,7 +103,7 @@ msym_error_t symmetrizeMoleculeLinear(msym_point_group_t *pg, int esl, msym_equi
             goto err;
         }
         
-        memset(v, 0, sizeof(double[pg->order][3]));
+        memset(v, 0, sizeof(double[3])*pg->order);
         
         for(int k = 0; k < es[i].length;k++){
             vproj(es[i].elements[k]->v, cinf->v, vinf[k]);
@@ -137,14 +137,14 @@ err:
 }
 
 
-msym_error_t symmetrizeOrbitals(msym_point_group_t *pg, int ssl, msym_subspace_t *ss, int *span, int basisl, msym_orbital_t basis[basisl], msym_thresholds_t *thresholds, double orb[basisl][basisl],double symorb[basisl][basisl]){
+msym_error_t symmetrizeOrbitals(msym_point_group_t *pg, int ssl, msym_subspace_t *ss, int *span, int basisl, msym_orbital_t basis[], msym_thresholds_t *thresholds, double **orb,double **symorb){
     msym_error_t ret = MSYM_SUCCESS;
-    double (*proj)[pg->ct->l][basisl] = malloc(sizeof(double[basisl][pg->ct->l][basisl]));
-    double *mem = malloc(sizeof(double[basisl]));
-    double (*comp)[pg->ct->l] = malloc(sizeof(double[basisl][pg->ct->l]));
+    double (***proj) = malloc(sizeof(double)*basisl*basisl*pg->ct->l);
+    double *mem = malloc(sizeof(double)*basisl);
+    double (**comp) = malloc(sizeof(double)*basisl*pg->ct->l);
     int *icomp = calloc(basisl,sizeof(int));
     int (*ispan) = calloc(pg->ct->l,sizeof(int));
-    memset(proj,0,sizeof(double[basisl][pg->ct->l][basisl]));
+    memset(proj,0,sizeof(double)*basisl*basisl*pg->ct->l);
     
     for(int o = 0;o < basisl;o++){
         double mcomp = -1.0;
@@ -224,7 +224,7 @@ err:
     return ret;
 }
 
-msym_error_t projectOntoSubspace(int d, double orb[d], msym_subspace_t *ss, msym_orbital_t basis[d], double mem[d], double proj[d]){
+msym_error_t projectOntoSubspace(int d, double orb[], msym_subspace_t *ss, msym_orbital_t basis[], double mem[], double proj[]){
     msym_error_t ret = MSYM_SUCCESS;
     if(ss->subspacel){
         for(int i = 0;i < ss->subspacel;i++){
@@ -232,8 +232,8 @@ msym_error_t projectOntoSubspace(int d, double orb[d], msym_subspace_t *ss, msym
         }
     } else {
         for(int i = 0; i < ss->d;i++){
-            double (*space)[ss->basisl] = (double (*)[ss->basisl]) ss->space;
-            memset(mem, 0, sizeof(double[d]));
+            double (**space) =  ss->space;
+            memset(mem, 0, sizeof(double)*d);
             for(int j = 0; j < ss->basisl;j++){
                 mem[ss->basis.o[j] - basis] = space[i][j];
             }
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.h b/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.h
index 364261b..6fd0955 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/symmetrize.h
@@ -18,7 +18,7 @@
 #include "permutation.h"
 
 msym_error_t symmetrizeMolecule(msym_point_group_t *pg, int esl, msym_equivalence_set_t *es, msym_permutation_t **perm, msym_thresholds_t *thresholds, double *err);
-msym_error_t symmetrizeOrbitals(msym_point_group_t *pg, int ssl, msym_subspace_t *ss, int *span, int basisl, msym_orbital_t basis[basisl], msym_thresholds_t *thresholds, double orb[basisl][basisl],double symorb[basisl][basisl]);
+msym_error_t symmetrizeOrbitals(msym_point_group_t *pg, int ssl, msym_subspace_t *ss, int *span, int basisl, msym_orbital_t *basis, msym_thresholds_t *thresholds, double **orb,double **symorb);
 msym_error_t symmetrizeTranslation(msym_point_group_t *pg, msym_equivalence_set_t *es, msym_permutation_t *perm, int pi, double translation[3]);
 
 
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.c b/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.c
index 11d7470..6e070a3 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.c
@@ -39,10 +39,10 @@ msym_error_t findSymmetryAsymmetricPolyhedron(msym_equivalence_set_t *es, double
 msym_error_t findSymmetrySpherical(msym_equivalence_set_t *es, double cm[3], double ev[3][3], msym_thresholds_t *thresholds, int *rsopsl, msym_symmetry_operation_t **rsops);
 msym_error_t findSymmetryCubic(msym_equivalence_set_t *es, double cm[3], double ev[3][3], msym_thresholds_t *thresholds, int *rsopsl, msym_symmetry_operation_t **rsops);
 msym_error_t findSymmetryUnknown(msym_equivalence_set_t *es, double cm[3], double ev[3][3], msym_thresholds_t *t, int *rsopsl, msym_symmetry_operation_t **rsops);
-msym_error_t reduceSymmetry(int sopsl, msym_symmetry_operation_t sops[sopsl], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops);
-msym_error_t filterSymmetryOperations(int sopsl, msym_symmetry_operation_t sops[sopsl], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops);
+msym_error_t reduceSymmetry(int sopsl, msym_symmetry_operation_t sops[], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops);
+msym_error_t filterSymmetryOperations(int sopsl, msym_symmetry_operation_t sops[], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops);
 
-msym_error_t findSymmetryOperations(int esl, msym_equivalence_set_t es[esl], msym_thresholds_t *t, int *lsops, msym_symmetry_operation_t **sops){
+msym_error_t findSymmetryOperations(int esl, msym_equivalence_set_t es[], msym_thresholds_t *t, int *lsops, msym_symmetry_operation_t **sops){
     msym_error_t ret = MSYM_SUCCESS;
     msym_symmetry_operation_t *rsops = NULL;
     int lrsops = 0;
@@ -654,7 +654,7 @@ msym_error_t findSymmetryCubic(msym_equivalence_set_t *es, double cm[3], double
     msym_symmetry_operation_t *sops = malloc(sizeof(msym_symmetry_operation_t[120]));
     int sopsl = 0;
     
-    double (**esv)[3] = malloc(sizeof(double (*[es->length])[3]));
+    double (**esv)[3] = malloc(sizeof(double *[3])*es->length);
     
     msym_symmetry_operation_t **sigma = malloc(16*sizeof(msym_symmetry_operation_t*)); //only 15, but we can overflow
     
@@ -1016,7 +1016,7 @@ err:
     return ret;
 }
 
-msym_error_t reduceSymmetry(int sopsl, msym_symmetry_operation_t sops[sopsl], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops){
+msym_error_t reduceSymmetry(int sopsl, msym_symmetry_operation_t sops[], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops){
     msym_error_t ret = MSYM_SUCCESS;
     
     int rsopsl = *isopsl;
@@ -1130,7 +1130,7 @@ msym_error_t reduceSymmetry(int sopsl, msym_symmetry_operation_t sops[sopsl], ms
                 add = vperpendicular(sops[i].v,cinf[0]->v,thresholds->angle);
             }
             if(add){
-                rsops = realloc(rsops, sizeof(msym_symmetry_operation_t[rsopsl+1]));
+                rsops = realloc(rsops, sizeof(msym_symmetry_operation_t)*(rsopsl+1));
                 copySymmetryOperation(&rsops[rsopsl], &sops[i]);
                 rsopsl++;
             }
@@ -1155,7 +1155,7 @@ msym_error_t reduceSymmetry(int sopsl, msym_symmetry_operation_t sops[sopsl], ms
                 if(remove){
                     rsopsl--;
                     copySymmetryOperation(&rsops[i], &rsops[rsopsl]);
-                    rsops = realloc(rsops, sizeof(msym_symmetry_operation_t[rsopsl]));
+                    rsops = realloc(rsops, sizeof(msym_symmetry_operation_t)*rsopsl);
                     i--;
                 } else if(vparallel(rsops[i].v,cinf[1]->v,thresholds->angle)){
                     if(vdot(rsops[i].v,cinf[1]->v) < 0){
@@ -1177,7 +1177,7 @@ err:
     return ret;
 }
 
-msym_error_t filterSymmetryOperations(int sopsl, msym_symmetry_operation_t sops[sopsl], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops){
+msym_error_t filterSymmetryOperations(int sopsl, msym_symmetry_operation_t sops[], msym_thresholds_t *thresholds, int *isopsl, msym_symmetry_operation_t **isops){
     msym_error_t ret = MSYM_SUCCESS;
     int rsopsl = *isopsl;
     msym_symmetry_operation_t *rsops = *isops;
@@ -1187,7 +1187,7 @@ msym_error_t filterSymmetryOperations(int sopsl, msym_symmetry_operation_t sops[
         if(!fsop){
             rsopsl--;
             copySymmetryOperation(&rsops[i], &rsops[rsopsl]);
-            rsops = realloc(rsops, sizeof(msym_symmetry_operation_t[rsopsl]));
+            rsops = realloc(rsops, sizeof(msym_symmetry_operation_t)*rsopsl);
             i--;
         } else if (rsops[i].type == PROPER_ROTATION || rsops[i].type == IMPROPER_ROTATION || rsops[i].type == REFLECTION){
             if(vdot(rsops[i].v,fsop->v) < 0){
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.h b/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.h
index 8a97c7b..bafd9ad 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/symmetry.h
@@ -14,6 +14,6 @@
 #include "msym.h"
 #include "symop.h"
 
-msym_error_t findSymmetryOperations(int esl, msym_equivalence_set_t es[esl], msym_thresholds_t *t, int *lsops, msym_symmetry_operation_t **sops);
+msym_error_t findSymmetryOperations(int esl, msym_equivalence_set_t *es, msym_thresholds_t *t, int *lsops, msym_symmetry_operation_t **sops);
 
 #endif /* defined(__MSYM_SYMMETRY_h) */
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/symop.c b/libavogadro/src/extensions/symmetry/libmsym/src/symop.c
index 7f10aaa..ccccfc8 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/symop.c
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/symop.c
@@ -86,7 +86,7 @@ void symopPow(msym_symmetry_operation_t *A, int pow, msym_symmetry_operation_t *
     }
 }
 
-void symmetryOperationName(msym_symmetry_operation_t* sop, int l, char buf[l]){
+void symmetryOperationName(msym_symmetry_operation_t* sop, int l, char buf[]){
     switch (sop->type) {
         case PROPER_ROTATION   : snprintf(buf, l, "C%d^%d",sop->order,sop->power); break;
         case IMPROPER_ROTATION : snprintf(buf, l, "S%d^%d",sop->order,sop->power); break;
@@ -97,7 +97,7 @@ void symmetryOperationName(msym_symmetry_operation_t* sop, int l, char buf[l]){
     }
 }
 
-void symmetryOperationShortName(msym_symmetry_operation_t* sop, int l, char buf[l]){
+void symmetryOperationShortName(msym_symmetry_operation_t* sop, int l, char buf[]){
     switch (sop->type) {
         case PROPER_ROTATION   : snprintf(buf, l, "C%d",sop->order); break;
         case IMPROPER_ROTATION : snprintf(buf, l, "S%d",sop->order); break;
diff --git a/libavogadro/src/extensions/symmetry/libmsym/src/symop.h b/libavogadro/src/extensions/symmetry/libmsym/src/symop.h
index 9b8530e..6bf4d2b 100644
--- a/libavogadro/src/extensions/symmetry/libmsym/src/symop.h
+++ b/libavogadro/src/extensions/symmetry/libmsym/src/symop.h
@@ -23,8 +23,8 @@ void symmetryOperationMatrix(msym_symmetry_operation_t *sop, double m[3][3]);
 void copySymmetryOperation(msym_symmetry_operation_t *dst, msym_symmetry_operation_t *src);
 msym_symmetry_operation_t *findSymmetryOperation(msym_symmetry_operation_t*, msym_symmetry_operation_t*, int, msym_thresholds_t *thresholds);
 void invertSymmetryOperation(msym_symmetry_operation_t *sop, msym_symmetry_operation_t *isop);
-void symmetryOperationName(msym_symmetry_operation_t* sop, int l, char buf[l]);
-void symmetryOperationShortName(msym_symmetry_operation_t* sop, int l, char buf[l]);
+void symmetryOperationName(msym_symmetry_operation_t* sop, int l, char *buf);
+void symmetryOperationShortName(msym_symmetry_operation_t* sop, int l, char *buf);
 void printSymmetryOperation(msym_symmetry_operation_t *sop);
 
 #endif /* defined(__MSYM__SYMOP_h) */
